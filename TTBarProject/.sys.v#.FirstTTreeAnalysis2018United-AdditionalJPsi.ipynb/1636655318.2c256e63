{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "hawaiian-importance",
   "metadata": {},
   "outputs": [],
   "source": [
    "import ROOT\n",
    "import glob\n",
    "import numpy as np\n",
    "ROOT.gROOT.ProcessLine(\".L FTFunctions.cpp\")\n",
    "ROOT.gInterpreter.Declare(\"\"\"\n",
    "    const UInt_t barWidth = 60;\n",
    "    ULong64_t processed = 0, totalEvents = 0;\n",
    "    std::string progressBar;\n",
    "    std::mutex barMutex; \n",
    "    auto registerEvents = [](ULong64_t nIncrement) {totalEvents += nIncrement;};\n",
    "    ROOT::RDF::RResultPtr<ULong64_t> AddProgressBar(ROOT::RDF::RNode df, int everyN=10000, int totalN=100000) {\n",
    "        registerEvents(totalN);\n",
    "        auto c = df.Count();\n",
    "        c.OnPartialResultSlot(everyN, [everyN] (unsigned int slot, ULong64_t &cnt){\n",
    "            std::lock_guard<std::mutex> l(barMutex);\n",
    "            processed += everyN; //everyN captured by value for this lambda\n",
    "            progressBar = \"[\";\n",
    "            for(UInt_t i = 0; i < static_cast<UInt_t>(static_cast<Float_t>(processed)/totalEvents*barWidth); ++i){\n",
    "                progressBar.push_back('|');\n",
    "            }\n",
    "            // escape the '\\' when defined in python string\n",
    "            std::cout << \"\\\\r\" << std::left << std::setw(barWidth) << progressBar << \"] \" << processed << \"/\" << totalEvents << std::flush;\n",
    "        });\n",
    "        return c;\n",
    "    }\n",
    "\"\"\")\n",
    "# Enables multithreading\n",
    "useRange = False\n",
    "if not useRange:\n",
    "    nThreads = 8\n",
    "    ROOT.ROOT.EnableImplicitMT(nThreads)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "nominated-resource",
   "metadata": {},
   "outputs": [],
   "source": [
    "listOfFilesData = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/SingleMuon/*/*.root\")\n",
    "listOfFilesMonteCarloTTToSemiLeptonic = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloTTTo2L2Nu = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTTo2L2Nu_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloWJetsToLNu = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/WJetsToLNu_TuneCP5_13TeV-madgraphMLM-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloST_tW_top = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/ST_tW_top_5f_inclusiveDecays_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloST_tchannel_top = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/ST_t-channel_top_4f_InclusiveDecays_TuneCP5_13TeV-powheg-madspin-pythia8/*/*.root\")\n",
    "\n",
    "listOfFilesMonteCarloTTToSemiLeptonic = listOfFilesMonteCarloTTToSemiLeptonic[0:1]\n",
    "listOfFilesMonteCarloTTTo2L2Nu = listOfFilesMonteCarloTTTo2L2Nu[0:1]\n",
    "listOfFilesMonteCarloWJetsToLNu = listOfFilesMonteCarloWJetsToLNu[0:1]\n",
    "listOfFilesMonteCarloST_tW_top = listOfFilesMonteCarloST_tW_top[0:1]\n",
    "listOfFilesMonteCarloST_tchannel_top = listOfFilesMonteCarloST_tchannel_top[0:1]\n",
    "\n",
    "dictOfListOfFiles = {\"Data\" : listOfFilesData, \"MonteCarloTTToSemiLeptonic\" : listOfFilesMonteCarloTTToSemiLeptonic, \"MonteCarloTTTo2L2Nu\" : listOfFilesMonteCarloTTTo2L2Nu, \"MonteCarloWJetsToLNu\" : listOfFilesMonteCarloWJetsToLNu, \"MonteCarloST_tW_top\" : listOfFilesMonteCarloST_tW_top, \"MonteCarloST_tchannel_top\" : listOfFilesMonteCarloST_tchannel_top} "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "international-panic",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<cppyy.gbl.ROOT.RDF.RResultPtr<ROOT::RDF::RCutFlowReport> object at 0xc162620>\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Warning in <TClass::Init>: no dictionary for class edm::Hash<1> is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ProcessHistory is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ProcessConfiguration is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ParameterSetBlob is available\n",
      "Warning in <TClass::Init>: no dictionary for class __pair_base<edm::Hash<1>,edm::ParameterSetBlob> is available\n",
      "Warning in <TClass::Init>: no dictionary for class pair<edm::Hash<1>,edm::ParameterSetBlob> is available\n"
     ]
    }
   ],
   "source": [
    "chain = {}\n",
    "meta = {}\n",
    "rdf = {}\n",
    "mrdf = {}\n",
    "nevents = {}\n",
    "sumweight = {}\n",
    "neventsVal = {}\n",
    "rdfTriggersAndMasks = {}\n",
    "rdfOnePlusMuons = {}\n",
    "rdfJetVariables = {}\n",
    "rdfTwoPlusJets = {}\n",
    "rdfNoMuTrigger = {}\n",
    "rdfmuOneBTaggedJet = {}\n",
    "rdfmu = {}\n",
    "rdfOtherMuons = {}\n",
    "rdfAllMuons = {}\n",
    "hist = {}\n",
    "report = {}\n",
    "stats = {}\n",
    "\n",
    "npArrays = {}\n",
    "\n",
    "for sample, fileList in dictOfListOfFiles.items():\n",
    "    \n",
    "    if sample == 'Data':\n",
    "        vecList = ROOT.std.vector(str)()\n",
    "\n",
    "        for element in dictOfListOfFiles['Data']:\n",
    "            vecList.push_back(element)\n",
    "\n",
    "        rdf['Data'] = ROOT.ROOT.RDataFrame(\"Events\", vecList)    \n",
    "        #mureport['Data'] = rdf['Data'].Report()\n",
    "        print(rdf['Data'].Report())\n",
    "        mrdf['Data'] = ROOT.ROOT.RDataFrame(\"Runs\", vecList)\n",
    "        \n",
    "        if useRange:\n",
    "            rdf['Data'] = rdf['Data'].Range(5000)\n",
    "            nrange = 5000\n",
    "            printcode = ' if(rdfentry_ % 5000 == 0) { std::cout << \"Processed entry \" << rdfentry_ << \"/' + str(nrange) + '\" << std::endl; } return rdfentry_;'\n",
    "            print(\"Data run\")\n",
    "            rdf['Data'] = rdf['Data'].Define(\"my_rdfentry\", printcode)\n",
    "            \n",
    "        #s = rdf['Data'].Min('my_rdfentry')\n",
    "                         \n",
    "        #c = rdf['Data'].Count()\n",
    "            \n",
    "\n",
    "        \n",
    "    else:\n",
    "        chain[sample] = ROOT.TChain(\"Events\")\n",
    "        meta[sample] = ROOT.TChain(\"Runs\")\n",
    "\n",
    "        for file in fileList:\n",
    "            #print(file, end=\" \")\n",
    "            \n",
    "            chain[sample].Add(file)\n",
    "            meta[sample].Add(file)\n",
    "\n",
    "        rdf[sample] = ROOT.ROOT.RDataFrame(chain[sample])\n",
    "        mrdf[sample] = ROOT.ROOT.RDataFrame(meta[sample])\n",
    "        \n",
    "        if useRange:\n",
    "            rdf[sample] = rdf[sample].Range(5000)\n",
    "            \n",
    "            printcode = ' if(rdfentry_ % 5000 == 0) { std::cout << \"Processed entry \" << rdfentry_ << \" \" << rdfslot_ << std::endl; } return rdfentry_;'\n",
    "            print(\"MC run\")\n",
    "            rdf[sample] = rdf[sample].Define(\"my_rdfentry\", printcode)\n",
    "        \n",
    "        nevents[sample] = mrdf[sample].Sum(\"genEventCount\")\n",
    "        sumweight[sample] = mrdf[sample].Sum(\"genEventSumw\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "paperback-video",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Semileptonic ttbar xsection: 364.3109\n",
    "#Single mu trigger for 2017 (B,C,D,E,F): \"HLT_IsoMu27\"\n",
    "#\"HLT_Ele35_WPTight_Gsf\"\n",
    "#lumiDict = {\"2017\": 41.53, \"2018\": 59.97}\n",
    "wgtFormula = {}\n",
    "\n",
    "# wgtFormula used to weight each event\n",
    "# XS = Literature Cross section of the process of interest (in picobarnes; the 1000 converts to femotobarnes), lumi = presumed luminosity of the data one is normalizing against; XS * lumi = # of expected events;\n",
    "# genWeight = quantity stored in every event which comes from the Monte Carlo generator telling you what the value of the generated event is (usually close to 1); it can be + or -; it also contains matching\n",
    "#     effeciency; tells you the Monte Carlo defined value of the event\n",
    "# sW = sum of weights; normalizes the genWeight\n",
    "lumiDict = {\"2018\": 59.97} #  brilcalc lumi --normtag /cvmfs/cms-bril.cern.ch/cms-lumi-pog/Normtags/normtag_PHYSICS.json -u /fb --begin 302031 --end 302663 --hltpath \"HLT_IsoMu27*\"\n",
    "wgtFormula['Data'] = \"1\"\n",
    "wgtFormula['MonteCarloTTToSemiLeptonic'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=364.31, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloTTToSemiLeptonic'].GetValue()))\n",
    "wgtFormula['MonteCarloTTTo2L2Nu'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=87.33, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloTTTo2L2Nu'].GetValue()))\n",
    "wgtFormula['MonteCarloWJetsToLNu'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=61526.7, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloWJetsToLNu'].GetValue()))\n",
    "wgtFormula['MonteCarloST_tW_top'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=71.7, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloST_tW_top'].GetValue()))\n",
    "wgtFormula['MonteCarloST_tchannel_top'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=130, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloST_tchannel_top'].GetValue()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "better-deputy",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cpp_code = \"\"\"\n",
    "typedef ROOT::VecOps::RVec<Float_t>                        RVec_f;\n",
    "typedef ROOT::VecOps::RVec<Int_t>                          RVec_i;\n",
    "typedef ROOT::VecOps::RVec<Long_t>                         RVec_l;\n",
    "\n",
    "class MatchOppositelyChargedMuons\n",
    "{\n",
    "    private:\n",
    "        RVec_f Paired_Muon_pt;\n",
    "        RVec_f Paired_Muon_eta;\n",
    "        RVec_f Paired_Muon_phi;\n",
    "        RVec_f Paired_Muon_mass;\n",
    "        RVec_i Paired_Muon_charge;\n",
    "        long Paired_EventNumber;\n",
    "        int FlagPair;\n",
    "        RVec_f Isolated_Muon_pt;\n",
    "        RVec_f Isolated_Muon_eta;\n",
    "        RVec_f Isolated_Muon_phi;\n",
    "        RVec_f Isolated_Muon_mass;\n",
    "        RVec_i Isolated_Muon_charge;\n",
    "\n",
    "\n",
    "    public:\n",
    "    MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair);\n",
    "        MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge);\n",
    "        RVec_f InvariantMassCalculator();\n",
    "        RVec_f OppositelyChargedMuonInvariantMassCalculator();\n",
    "        RVec_f ThreeMuonInvariantMassCalculator();\n",
    "        RVec_f DeltaEtaCalculator();\n",
    "        RVec_f DeltaPhiCalculator();\n",
    "        RVec_f DeltaRCalculator();\n",
    "        int ReturnFlagPair();\n",
    "};\n",
    "\n",
    "MatchOppositelyChargedMuons::MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair)\n",
    "{\n",
    "    this->Paired_Muon_pt = Paired_Muon_pt;\n",
    "    this->Paired_Muon_eta = Paired_Muon_eta;\n",
    "    this->Paired_Muon_phi = Paired_Muon_phi;\n",
    "    this->Paired_Muon_mass = Paired_Muon_mass;\n",
    "    this->Paired_Muon_charge = Paired_Muon_charge;\n",
    "    this->Paired_EventNumber = Paired_EventNumber;\n",
    "    this->FlagPair = FlagPair;\n",
    "    this->Isolated_Muon_pt = {};\n",
    "    this->Isolated_Muon_eta = {};\n",
    "    this->Isolated_Muon_phi = {};\n",
    "    this->Isolated_Muon_mass = {};\n",
    "    this->Isolated_Muon_charge = {};\n",
    "}\n",
    "\n",
    "MatchOppositelyChargedMuons::MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge)\n",
    "{\n",
    "    this->Paired_Muon_pt = Paired_Muon_pt;\n",
    "    this->Paired_Muon_eta = Paired_Muon_eta;\n",
    "    this->Paired_Muon_phi = Paired_Muon_phi;\n",
    "    this->Paired_Muon_mass = Paired_Muon_mass;\n",
    "    this->Paired_Muon_charge = Paired_Muon_charge;\n",
    "    this->Paired_EventNumber = Paired_EventNumber;\n",
    "    this->FlagPair = FlagPair;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "}\n",
    "\n",
    "\n",
    "/* This function matches each muon with oppositely charged muons. */\n",
    "RVec_f MatchOppositelyChargedMuons::OppositelyChargedMuonInvariantMassCalculator()\n",
    "{ \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f InvariantMasses {};\n",
    "    \n",
    "    float im = 0;\n",
    " \n",
    "    /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "    for(int i = 0; i < this->Paired_Muon_charge.size(); i++)\n",
    "    {    \n",
    "\n",
    "        FirstMuonCharge = this->Paired_Muon_charge[i];\n",
    "        \n",
    "        /* If charges are opposite, calculate the invariant mass of them */\n",
    "        for(int j = i+1; j < this->Paired_Muon_charge.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->Paired_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {\n",
    "                pt.push_back(Paired_Muon_pt[i]);\n",
    "                eta.push_back(Paired_Muon_eta[i]);\n",
    "                phi.push_back(Paired_Muon_phi[i]);\n",
    "                mass.push_back(Paired_Muon_mass[i]);\n",
    "                    \n",
    "                pt.push_back(Paired_Muon_pt[j]);\n",
    "                eta.push_back(Paired_Muon_eta[j]);\n",
    "                phi.push_back(Paired_Muon_phi[j]);\n",
    "                mass.push_back(Paired_Muon_mass[j]);\n",
    "                    \n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                \n",
    "                InvariantMasses.push_back(im);\n",
    "                \n",
    "                this->FlagPair = 1;\n",
    "                    \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return InvariantMasses;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::ThreeMuonInvariantMassCalculator()\n",
    "{ \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f InvariantMasses {};\n",
    "    \n",
    "    float im = 0;\n",
    " \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "    \n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->Paired_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->Paired_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->Paired_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->Paired_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {\n",
    "                    pt.push_back(Paired_Muon_pt[i]);\n",
    "                    eta.push_back(Paired_Muon_eta[i]);\n",
    "                    phi.push_back(Paired_Muon_phi[i]);\n",
    "                    mass.push_back(Paired_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(Paired_Muon_pt[j]);\n",
    "                    eta.push_back(Paired_Muon_eta[j]);\n",
    "                    phi.push_back(Paired_Muon_phi[j]);\n",
    "                    mass.push_back(Paired_Muon_mass[j]);\n",
    "                    \n",
    "                    pt.push_back(Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(Isolated_Muon_mass[k]);\n",
    "\n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "\n",
    "                    InvariantMasses.push_back(im);\n",
    "\n",
    "                    this->FlagPair = 1;\n",
    "\n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return InvariantMasses;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::DeltaEtaCalculator()\n",
    "{ \n",
    "    float DeltaEtaIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaEtaRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_eta.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->Paired_Muon_eta.size(); j++)\n",
    "        {    \n",
    "                    DeltaEtaIndividual = this->Isolated_Muon_eta[i] - this->Paired_Muon_eta[j];\n",
    "\n",
    "                    DeltaEtaRVec.push_back(DeltaEtaIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaEtaRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::DeltaPhiCalculator()\n",
    "{ \n",
    "    RVec_f PhiAll {};\n",
    "    RVec_f PhiJPsi {};\n",
    "    \n",
    "    RVec_f DeltaPhiIndividual {};\n",
    "    \n",
    "    RVec_f DeltaPhiRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->Paired_Muon_phi.size(); j++)\n",
    "        {    \n",
    "\n",
    "                    PhiAll.push_back(this->Isolated_Muon_phi[i]);\n",
    "\n",
    "                    PhiJPsi.push_back(this->Paired_Muon_phi[j]);\n",
    "\n",
    "                    DeltaPhiIndividual = ROOT::VecOps::DeltaPhi(PhiAll, PhiJPsi);\n",
    "\n",
    "                    for(int k = 0; k < DeltaPhiIndividual.size(); k++)\n",
    "                    {\n",
    "                        DeltaPhiRVec.push_back(DeltaPhiIndividual[k]);\n",
    "                    }\n",
    "\n",
    "                    PhiAll.clear();\n",
    "                    PhiJPsi.clear();\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaPhiRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::DeltaRCalculator()\n",
    "{ \n",
    "    RVec_f EtaAll {};\n",
    "    RVec_f PhiAll {};\n",
    "    RVec_f EtaJPsi {};\n",
    "    RVec_f PhiJPsi {};\n",
    "    \n",
    "    RVec_f DeltaRIndividual {};\n",
    "    \n",
    "    RVec_f DeltaRRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->Paired_Muon_phi.size(); j++)\n",
    "        {    \n",
    "                    EtaAll.push_back(this->Isolated_Muon_eta[i]);\n",
    "                    PhiAll.push_back(this->Isolated_Muon_phi[i]);\n",
    "                    \n",
    "                    EtaJPsi.push_back(this->Paired_Muon_eta[j]);\n",
    "                    PhiJPsi.push_back(this->Paired_Muon_phi[j]);\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaAll, EtaJPsi, PhiAll, PhiJPsi);\n",
    "\n",
    "                    for(int k = 0; k < DeltaRIndividual.size(); k++)\n",
    "                    {\n",
    "                        DeltaRRVec.push_back(DeltaRIndividual[k]);\n",
    "                    }\n",
    "\n",
    "                    EtaAll.clear();\n",
    "                    PhiAll.clear();\n",
    "                    EtaJPsi.clear();\n",
    "                    PhiJPsi.clear();\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaRRVec;\n",
    "}\n",
    "\n",
    "\n",
    "int MatchOppositelyChargedMuons::ReturnFlagPair()\n",
    "{\n",
    "    return this->FlagPair;\n",
    "}\n",
    "\"\"\"\n",
    "\n",
    "ROOT.gInterpreter.Declare(cpp_code)\n",
    "\n",
    "#rvf = ROOT.VecOps.RVec(float)([2.71,3.14])\n",
    "#rvi = ROOT.VecOps.RVec(int)([1,-1])\n",
    "\n",
    "#x = ROOT.MatchOppositelyChargedMuons(rvf, rvf, rvf, rvf, rvi, 123456789)\n",
    "#print(x.InvariantMassCalculator())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "fixed-manor",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Object selection (masks) and cuts (filters)\n",
    "# LumiXS is lumi * xs\n",
    "#.Define(\"Junk\", 'if(rdfentry_ % 200000 == 0){ std::cout << \"Processed \" << rdfentry_ << \" entries on slot \" << rdfslot_ << std::endl;} return rdfentry_;')\n",
    "\n",
    "# Initial cuts for finding muons, isolated or not.\n",
    "for sample in dictOfListOfFiles:\n",
    "    # The first filter determines whether there is a single muon or not.  In addition, mu_mask is defined which will later filter out processes with at least one good, isolated muon. mu_veto\n",
    "    # is defined which will later filter out events with muons which are vetoed. Also, jpsi_mu_candidate mask is defined and will be later used to filter out possible oppositely charged muon\n",
    "    # candidates from events with at least one, good, isolated muon.\n",
    "    rdfTriggersAndMasks[sample] = rdf[sample].Filter(\"HLT_IsoMu27 == true\", \"HLTTriggerSingleMuonTrigger\")\\\n",
    "        .Define(\"LumiXS\",wgtFormula[sample])\\\n",
    "        .Define(\"isolated_mu_mask\", \"Muon_pt > 30 && abs(Muon_eta) < 2.4 && Muon_tightId == true && Muon_pfIsoId >= 4\")\\\n",
    "        .Define(\"isolated_mu_veto\", \"Muon_pt > 10 && abs(Muon_eta) < 2.4 && Muon_looseId == true && Muon_pfIsoId >= 4 && isolated_mu_mask == false\")\\\n",
    "        .Define(\"jpsi_mu_candidate_mask\", \"Muon_pt > 3 && Muon_mediumId == true && isolated_mu_mask == false\")\n",
    "    # The second filter keeps all events with at least one good, isolated muon.  In addtion, the pt, eta, etc. of the isolated muon is determined.\n",
    "    rdfOnePlusMuons[sample] = rdfTriggersAndMasks[sample].Filter(\"Sum(isolated_mu_mask) == 1\", \"Exactly One Good Isolated Muon\")\\\n",
    "        .Define(\"IsolatedMuon_pt\", \"Muon_pt[isolated_mu_mask]\")\\\n",
    "        .Define(\"IsolatedMuon_eta\", \"Muon_eta[isolated_mu_mask]\")\\\n",
    "        .Define(\"IsolatedMuon_phi\", \"Muon_phi[isolated_mu_mask]\")\\\n",
    "        .Define(\"IsolatedMuon_mass\", \"Muon_mass[isolated_mu_mask]\")\\\n",
    "        .Define(\"IsolatedMuon_charge\", \"Muon_charge[isolated_mu_mask]\")\\\n",
    "        .Define(\"IsolatedMuon_pfRelIso03_all\", \"Muon_pfRelIso03_all[isolated_mu_mask]\")\\\n",
    "        .Define(\"IsolatedMuon_pfRelIso03_chg\", \"Muon_pfRelIso03_chg[isolated_mu_mask]\")\\\n",
    "        .Define(\"IsolatedMuon_pfRelIso04_all\", \"Muon_pfRelIso04_all[isolated_mu_mask]\")\n",
    "    # No filter here, but criteria for jets are spelled out and the pt, eta, phi, etc. of jets are defined\n",
    "    rdfJetVariables[sample] = rdfOnePlusMuons[sample]\\\n",
    "        .Define(\"jet_mask\", \"ROOT::VecOps::RVec<Int_t> jmask = (Jet_pt >= 30 && abs(Jet_eta) <= 2.5 && Jet_jetId >= 2); \"\\\n",
    "                          \"for(int i=0; i < IsolatedMuon_pt.size(); ++i){\"\\\n",
    "                              \"ROOT::VecOps::RVec<Float_t> dr;\"\\\n",
    "                              \"for(int j=0; j < jmask.size(); ++j){\"\\\n",
    "                                  \"dr.push_back(ROOT::VecOps::DeltaR(Jet_eta.at(j), IsolatedMuon_eta.at(i), Jet_phi.at(j), IsolatedMuon_phi.at(i)));}\"\\\n",
    "                                  \"jmask = jmask && dr >= 0.4;\"\\\n",
    "                                  \"dr.clear();}\"\\\n",
    "                          \"return jmask;\")\\\n",
    "        .Define(\"MediumBJetMask\", \"Jet_btagDeepFlavB > 0.3033 && jet_mask\" )\\\n",
    "        .Define(\"MTofMETandMu\", \"FTA::transverseMassMET(IsolatedMuon_pt, IsolatedMuon_phi, IsolatedMuon_mass, MET_pt, MET_phi)\")\\\n",
    "        .Define(\"Num_Jets\", \"Jet_pt[jet_mask].size()\")\\\n",
    "        .Define(\"SJet1_pt\", \"Jet_pt[jet_mask].size() > 0 ? Jet_pt[jet_mask].at(0) : -500\")\\\n",
    "        .Define(\"SJet2_pt\", \"Jet_pt[jet_mask].size() > 1 ? Jet_pt[jet_mask].at(1) : -500\")\\\n",
    "        .Define(\"SJet1_eta\", \"Jet_eta[jet_mask].size() > 0 ? Jet_eta[jet_mask].at(0) : 500\")\\\n",
    "        .Define(\"SJet2_eta\", \"Jet_eta[jet_mask].size() > 1 ? Jet_eta[jet_mask].at(1) : 500\")\\\n",
    "        .Define(\"SJet1_phi\", \"Jet_phi[jet_mask].size() > 0 ? Jet_phi[jet_mask].at(0) : 500\")\\\n",
    "        .Define(\"SJet2_phi\", \"Jet_phi[jet_mask].size() > 1 ? Jet_phi[jet_mask].at(1) : 500\")\\\n",
    "        .Define(\"SJet_btagDeepFlavB\", \"Jet_btagDeepFlavB[jet_mask]\")\\\n",
    "        .Define(\"Num_BTaggedJets\", \"Sum(MediumBJetMask)\")\\\n",
    "        .Define(\"Ht\", \"Sum(Jet_pt[jet_mask])\")\n",
    "    # This third filter leaves only events with at least 4 jets\n",
    "    rdfTwoPlusJets[sample] = rdfJetVariables[sample].Filter(\"Num_Jets >= 4\", \"At Least Four Jets\")\\\n",
    "        .Define(\"DeepJetB\", \"Jet_pt[jet_mask].size() > 0 ? Jet_btagDeepFlavB[jet_mask].at(0) : 0\")\\\n",
    "        .Define(\"Num_Muons\", \"Muon_pt[isolated_mu_mask].size()\")\n",
    "    # This fourth filter leaves only events with at least 1 b-tagged jet\n",
    "    rdfmuOneBTaggedJet[sample] = rdfTwoPlusJets[sample].Filter(\"Num_BTaggedJets >= 1\", \"At Least One B-Tagged Jet\")\n",
    "    # This fifth filter keeps only events with no vetoed muons\n",
    "    rdfmu[sample] = rdfmuOneBTaggedJet[sample].Filter(\"Sum(isolated_mu_veto) == 0\", \"No Vetoed Muons\")\n",
    "    \n",
    "    # This sixth filter keeps events with at least one jpsi candidate (should this be upped to 2?).  This is on top of all the prvious criteria.  Of the muons which have made it this far, we apply the\n",
    "    # jpsi_mu_candidate_mask to determine which are J/Psi-related muons.\n",
    "    rdfOtherMuons[sample] = rdfmu[sample].Filter(\"Sum(jpsi_mu_candidate_mask) >= 2\", \"JPsi Candidate\")\\\n",
    "        .Define(\"JPsiMuons_pt\", \"Muon_pt[jpsi_mu_candidate_mask]\")\\\n",
    "        .Define(\"JPsiMuons_eta\", \"Muon_eta[jpsi_mu_candidate_mask]\")\\\n",
    "        .Define(\"JPsiMuons_phi\", \"Muon_phi[jpsi_mu_candidate_mask]\")\\\n",
    "        .Define(\"JPsiMuons_charge\", \"Muon_charge[jpsi_mu_candidate_mask]\")\\\n",
    "        .Define(\"JPsiMuons_mass\", \"Muon_mass[jpsi_mu_candidate_mask]\")\\\n",
    "        .Define(\"JPsiMuons_multiplicity\", \"Muon_pt[jpsi_mu_candidate_mask].size()\")\\\n",
    "        .Define(\"InvariantMasses\", \"std::cout << rdfentry_ << std::endl; int FlagPair = -1; auto c = MatchOppositelyChargedMuons(JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge, event, FlagPair); return c.OppositelyChargedMuonInvariantMassCalculator()\")\\\n",
    "        .Define(\"InvariantMassesAllMuons\", \"std::cout << rdfentry_ << std::endl; int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.ThreeMuonInvariantMassCalculator()\")\\\n",
    "        .Define(\"DeltaEta\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.DeltaEtaCalculator()\")\\\n",
    "        .Define(\"DeltaPhi\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.DeltaPhiCalculator()\")\\\n",
    "        .Define(\"DeltaR\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.DeltaRCalculator()\")\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "36c70404",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{ 11.3163f, 35.2814f, 9.85556f, 31.2600f, 7.73461f, 6.38357f }\n"
     ]
    }
   ],
   "source": [
    "pt = ROOT.VecOps.RVec['float']([1,2,3,4,5])\n",
    "eta = ROOT.VecOps.RVec['float']([1.5,2.5,3.5,4.5,5.5])\n",
    "phi = ROOT.VecOps.RVec['float']([1.6,1.7,1.8,1.9,2.0])\n",
    "mass = ROOT.VecOps.RVec['float']([5,4,3,2,1])\n",
    "charge = ROOT.VecOps.RVec['int']([-1,1,-1,1,-1])\n",
    "event = 12\n",
    "FlagPair = -1\n",
    "v = ROOT.MatchOppositelyChargedMuons(pt, eta, phi, mass, charge, event, FlagPair)\n",
    "print(v.OppositelyChargedMuonInvariantMassCalculator())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "sixth-northern",
   "metadata": {},
   "outputs": [],
   "source": [
    "for sample in dictOfListOfFiles:\n",
    "    \n",
    "    if sample not in hist.keys():\n",
    "        hist[sample] = {}\n",
    "        stats[sample] = {}\n",
    "        report[sample] = rdf[sample].Report()\n",
    "        \n",
    "    #stats[sample][\"countercode\"] = rdf[sample].Min('my_rdfentry')\n",
    "        \n",
    "    if sample == 'Data':\n",
    "        \n",
    "        hist['Data'][\"isolated_mu_pt\"] = rdfmu['Data'].Histo1D((\"mu_pt\",\"Muon Transverse Momentum; Pt (GeV);Events\",100,20,220),\"IsolatedMuon_pt\")\n",
    "        hist['Data'][\"isolated_mu_eta\"] = rdfmu['Data'].Histo1D((\"mu_eta\", \"Muon Pseudorapidity; Eta; Events\",100,-3,3),\"IsolatedMuon_eta\")\n",
    "        hist['Data'][\"isolated_mu_phi\"] = rdfmu['Data'].Histo1D((\"mu_phi\", \"Muon Angle; Phi (Radians); Events\",100,-3.5,3.5),\"IsolatedMuon_phi\")\n",
    "        hist['Data'][\"jet1_pt\"] = rdfmu['Data'].Histo1D((\"jet1_pt\", \"Jet Transverse Momentum for Leading Jet; Pt (GeV); Events\", 100, 20, 200), \"SJet1_pt\")\n",
    "        hist['Data'][\"jet2_pt\"] = rdfmu['Data'].Histo1D((\"jet2_pt\", \"Jet Transverse Momentum for Subleading Jet; Pt (GeV); Events\", 100, 20, 200), \"SJet2_pt\")\n",
    "        hist['Data'][\"jet1_eta\"] = rdfmu['Data'].Histo1D((\"jet1_eta\", \"Jet Pseudorapidity for Leading Jet; Eta; Events\", 100, -3, 3), \"SJet1_eta\")\n",
    "        hist['Data'][\"jet2_eta\"] = rdfmu['Data'].Histo1D((\"jet2_eta\", \"Jet Pseudorapidity for Subleading Jet; Eta; Events\", 100, -3, 3), \"SJet2_eta\")\n",
    "        hist['Data'][\"jet1_phi\"] = rdfmu['Data'].Histo1D((\"jet1_phi\", \"Jet Angle for Leading Jet; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet1_phi\")\n",
    "        hist['Data'][\"jet2_phi\"] = rdfmu['Data'].Histo1D((\"jet2_phi\", \"Jet Angle for Subleading Jet; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet2_phi\")\n",
    "        hist['Data'][\"jet_deep\"] = rdfmu['Data'].Histo1D((\"jet_deep\", \"Deep Jet B Discriminator; Discriminant Value; Events\", 100, 0, 1), \"DeepJetB\")\n",
    "        hist['Data'][\"number_of_jets\"] = rdfmu['Data'].Histo1D((\"number_of_jets\", \"Number of Jets; Number Of Jets; Events\", 20, 0, 20), \"Num_Jets\") \n",
    "        hist['Data'][\"number_of_muons\"] = rdfmu['Data'].Histo1D((\"number_of_muons\", \"Number of Muons; Number of Muons; Events\", 5, 0, 5), \"Num_Muons\")\n",
    "        hist['Data'][\"transverse_mass\"] = rdfmu['Data'].Histo1D((\"transverse_mass\", \"Transverse Mass; Transverse Mass (GeV); Events\", 150, 0, 150), \"MTofMETandMu\")\n",
    "        hist['Data'][\"missing_transverse_momentum\"] = rdfmu['Data'].Histo1D((\"missing_transverse_momentum\", \"Missing Transverse Momentum; Missing Transverse Momentum(GeV); Events\", 150, 0, 300), \"MET_pt\")\n",
    "        hist['Data'][\"ht\"] = rdfmu['Data'].Histo1D((\"ht\", \"Ht; Ht; Events\", 300, 0, 1500), \"Ht\")\n",
    "        hist['Data'][\"isolated_muon_pfRelIso03_all\"] = rdfmu['Data'].Histo1D((\"muon_pfRelIso03_all\", \"Muon Pf Rel Iso 03 (All); Muon Pf Rel Iso 03 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_all\")\n",
    "        hist['Data'][\"isolated_muon_pfRelIso03_chg\"] = rdfmu['Data'].Histo1D((\"muon_pfRelIso03_chg\", \"Muon Pf Rel Iso 03 (Chg); Muon Pf Rel Iso 03 (Chg); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_chg\")\n",
    "        hist['Data'][\"isolated_muon_pfRelIso04_all\"] = rdfmu['Data'].Histo1D((\"muon_pfRelIso04_all\", \"Muon Pf Rel Iso 04 (All); Muon Pf Rel Iso 04 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso04_all\")\n",
    "        hist['Data'][\"invariant_masses\"] = rdfOtherMuons['Data'].Histo1D((\"invariant_masses\", \"Invariant Masses for Two Muons (Oppositely Charged); Invariant Masses; Events\", 50, .5, 12), \"InvariantMasses\")        \n",
    "        hist['Data'][\"invariant_masses_zoomed\"] = rdfOtherMuons['Data'].Histo1D((\"invariant_masses_zoomed\", \"Invariant Masses for Two Muons (Oppositely Charged); Invariant Masses; Events\", 50, 2.8, 3.4), \"InvariantMasses\")\n",
    "        hist['Data'][\"jpsi_muons_pt\"] = rdfOtherMuons['Data'].Histo1D((\"Pt for JPsi Muons\", \"Transverse Momentum for JPsi Muons; Pt; Events\", 150, 2.8, 75), \"JPsiMuons_pt\")\n",
    "        hist['Data'][\"jpsi_muons_eta\"] = rdfOtherMuons['Data'].Histo1D((\"Eta for JPsi Muons\", \"Pseudorapidity for JPsi Muons; Eta; Events\", 50, -3, 3), \"JPsiMuons_eta\")\n",
    "        hist['Data'][\"jpsi_muons_phi\"] = rdfOtherMuons['Data'].Histo1D((\"Phi for JPsi Muons\", \"Angle for JPsi Muons; Phi; Events\", 50, -3.5, 3.5), \"JPsiMuons_phi\")\n",
    "        hist['Data'][\"jpsi_muons_multiplicity\"] = rdfOtherMuons['Data'].Histo1D((\"jpsi_muon_multiplicity\", \"Number of J/Psi Muons; Number of J/Psi Muons; Events\", 8, 0, 8), \"JPsiMuons_multiplicity\")\n",
    "        hist['Data'][\"delta_eta\"] = rdfOtherMuons['Data'].Histo1D((\"Delta Eta for Isolated Muon - JPsi Muons\", \"Delta Eta for Isolated Muon - JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEta\")\n",
    "        hist['Data'][\"delta_phi\"] = rdfOtherMuons['Data'].Histo1D((\"Delta Phi for Isolated Muon - JPsi Muons\", \"Delta Phi for Isolated Muon - JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhi\")\n",
    "        hist['Data'][\"delta_r\"] = rdfOtherMuons['Data'].Histo1D((\"Delta R for Isolated and JPsi Muons\", \"Delta R for Isolated and JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaR\")\n",
    "        hist['Data'][\"invariant_masses_all_muons\"] = rdfOtherMuons['Data'].Histo1D((\"invariant_masses_all_muons\", \"Invariant Masses for Three Muons (Isolated and Paired, Oppositely Charged); Invariant Masses; Events\", 50, .5, 200), \"InvariantMassesAllMuons\")\n",
    "\n",
    "    else:\n",
    "        \n",
    "        hist[sample][\"isolated_mu_pt\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"mu_pt\",\"Monte Carlo \" + sample + \";Pt (GeV);Events\",100,20,220),\"IsolatedMuon_pt\",\"LumiXS\")\n",
    "        hist[sample][\"isolated_mu_eta\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"mu_eta\", \"Monte Carlo \" + sample + \"; Eta; Events\",100,-3,3),\"IsolatedMuon_eta\",\"LumiXS\")\n",
    "        hist[sample][\"isolated_mu_phi\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"mu_phi\", \"Monte Carlo \" + sample + \"; Phi (Radians); Events\",100,-3.5,3.5),\"IsolatedMuon_phi\",\"LumiXS\")\n",
    "        hist[sample][\"jet1_pt\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet1_pt\", \"Monte Carlo \" + sample + \"; Pt (GeV); Events\", 100, 20, 200), \"SJet1_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jet2_pt\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet2_pt\", \"Monte Carlo \" + sample + \"; Pt (GeV); Events\", 100, 20, 200), \"SJet2_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jet1_eta\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet1_eta\", \"Monte Carlo \" + sample + \"; Eta; Events\", 100, -3, 3), \"SJet1_eta\", \"LumiXS\")\n",
    "        hist[sample][\"jet2_eta\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet2_eta\", \"Monte Carlo \" + sample +\"; Eta; Events\", 100, -3, 3), \"SJet2_eta\", \"LumiXS\")\n",
    "        hist[sample][\"jet1_phi\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet1_phi\", \"Monte Carlo \" + sample + \"; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet1_phi\", \"LumiXS\")\n",
    "        hist[sample][\"jet2_phi\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet2_phi\", \"Monte Carlo \" + sample +\"; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet2_phi\", \"LumiXS\")\n",
    "        hist[sample][\"jet_deep\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet_deep\", \"Monte Carlo \" + sample +\"; Discriminant Value; Events\", 100, 0, 1), \"DeepJetB\", \"LumiXS\")\n",
    "        hist[sample][\"number_of_jets\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"number_of_jets\", \"Monte Carlo \" + sample +\"; Number Of Jets; Events\", 20, 0, 20), \"Num_Jets\", \"LumiXS\") \n",
    "        hist[sample][\"number_of_muons\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"number_of_muons\", \"Monte Carlo \" + sample +\"; Number of Muons; Events\", 5, 0, 5), \"Num_Muons\", \"LumiXS\")\n",
    "        hist[sample][\"transverse_mass\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"transverse_mass\", \"Monte Carlo \" + sample +\"; Transverse Mass (GeV); Events\", 150, 0, 150), \"MTofMETandMu\", \"LumiXS\")\n",
    "        hist[sample][\"missing_transverse_momentum\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"missing_transverse_momentum\", \"Monte Carlo\" + sample + \"; Missing Transverse Momentum(GeV); Events\", 150, 0, 300), \"MET_pt\", \"LumiXS\")\n",
    "        hist[sample][\"ht\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"ht\", \"Monte Carlo \" + sample + \"; Ht; Events\", 300, 0, 1500), \"Ht\", \"LumiXS\")\n",
    "        hist[sample][\"isolated_muon_pfRelIso03_all\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"muon_pfRelIso03_all\", \"Monte Carlo \" + sample + \"; Muon Pf Rel Iso 03 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_all\", \"LumiXS\")\n",
    "        hist[sample][\"isolated_muon_pfRelIso03_chg\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"muon_pfRelIso03_chg\", \"Monte Carlo \" + sample + \"; Muon Pf Rel Iso 03 (Chg); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_chg\", \"LumiXS\")\n",
    "        hist[sample][\"isolated_muon_pfRelIso04_all\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"muon_pfRelIso04_all\", \"Monte Carlo \" + sample + \"; Muon Pf Rel Iso 04 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso04_all\", \"LumiXS\")\n",
    "        hist[sample][\"invariant_masses\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"invariant_masses\", \"Monte Carlo \" + sample + \"; Invariant Masses for Two Muons (Oppositely Charged); Invariant Masses; Events\", 50, .5, 12), \"InvariantMasses\", \"LumiXS\")\n",
    "        hist[sample][\"invariant_masses_zoomed\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"invariant_masses_zoomed\", \"Monte Carlo \" + sample + \"; Invariant Masses for Two Muons (Oppositely Charged); Events\", 50, 2.8, 3.4), \"InvariantMasses\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_pt\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_pt\", \"Monte Carlo \" + sample + \"; Transverse Momentum for JPsi Muons; Pt; Events\", 150, 2.8, 75), \"JPsiMuons_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_eta\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_eta\", \"Monte Carlo \" + sample + \"; Pseudorapidity for JPsi Muons; Eta; Events\", 50, -3, 3), \"JPsiMuons_eta\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_phi\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_phi\", \"Monte Carlo \" + sample + \"; Angle for JPsi Muons; Phi; Events\", 50, -3.5, 3.5), \"JPsiMuons_phi\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_multiplicity\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muon_multiplicity\", \"Monte Carlo\" + sample + \"; Number of J/Psi Muons; Number of J/Psi Muons; Events\", 8, 0, 8), \"JPsiMuons_multiplicity\", \"LumiXS\")\n",
    "        hist[sample][\"delta_eta\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"delta_eta\", \"Monte Carlo \" + sample + \"; Delta Eta for Isolated Muon - JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEta\", \"LumiXS\")\n",
    "        hist[sample][\"delta_phi\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"delta_phi\", \"Monte Carlo \" + sample + \"; Delta Phi for Isolated Muon - JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhi\", \"LumiXS\")\n",
    "        hist[sample][\"delta_r\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"delta_r\", \"Monte Carlo \" + sample + \"; Delta R for Isolated and JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaR\", \"LumiXS\")\n",
    "        hist[sample][\"invariant_masses_all_muons\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"invariant_masses_all_muons\", \"Monte Carlo\" + sample + \"; Invariant Masses for Three Muons (Isolated and Paired, Oppositely Charged); Invariant Masses; Events\", 50, .5, 200), \"InvariantMassesAllMuons\", \"LumiXS\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "prospective-permission",
   "metadata": {},
   "outputs": [],
   "source": [
    "for sample in dictOfListOfFiles:\n",
    "\n",
    "    ROOT.RDF.SaveGraph(rdf[sample], str(sample) + \".dot\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "small-volleyball",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3c534cf0>\n",
      "Name: 2018___Mu___Data___mu_pt___nominal Title: Muon Transverse Momentum NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3c4fba10>\n",
      "Name: 2018___Mu___Data___mu_eta___nominal Title: Muon Pseudorapidity NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0xc7875d0>\n",
      "Name: 2018___Mu___Data___mu_phi___nominal Title: Muon Angle NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3c510440>\n",
      "Name: 2018___Mu___Data___jet1_pt___nominal Title: Jet Transverse Momentum for Leading Jet NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3c52c930>\n",
      "Name: 2018___Mu___Data___jet2_pt___nominal Title: Jet Transverse Momentum for Subleading Jet NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3cd21680>\n",
      "Name: 2018___Mu___Data___jet1_eta___nominal Title: Jet Pseudorapidity for Leading Jet NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ce3fb50>\n",
      "Name: 2018___Mu___Data___jet2_eta___nominal Title: Jet Pseudorapidity for Subleading Jet NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3cd62490>\n",
      "Name: 2018___Mu___Data___jet1_phi___nominal Title: Jet Angle for Leading Jet NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3cd39f50>\n",
      "Name: 2018___Mu___Data___jet2_phi___nominal Title: Jet Angle for Subleading Jet NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3c538040>\n",
      "Name: 2018___Mu___Data___jet_deep___nominal Title: Deep Jet B Discriminator NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3cd61ab0>\n",
      "Name: 2018___Mu___Data___number_of_jets___nominal Title: Number of Jets NbinsX: 20\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ce0d300>\n",
      "Name: 2018___Mu___Data___number_of_muons___nominal Title: Number of Muons NbinsX: 5\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3cd61e70>\n",
      "Name: 2018___Mu___Data___transverse_mass___nominal Title: Transverse Mass NbinsX: 150\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3c531130>\n"
     ]
    }
   ],
   "source": [
    "for sample in dictOfListOfFiles:\n",
    "    #npArrays[sample] = rdfOtherMuons[sample].AsNumpy([\"InvariantMasses_0\", \"InvariantMasses_1\"])\n",
    "            \n",
    "    cutflow = report[sample].GetValue()\n",
    "    cutflow.Print()\n",
    "    \n",
    "    era = \"2018\"\n",
    "    process = sample\n",
    "    channel = \"Mu\"\n",
    "    syst = \"nominal\"\n",
    "\n",
    "    outFile = ROOT.TFile.Open(\"{}_{}_{}.root\".format(era, channel, process), \"RECREATE\")\n",
    "    for name, hist_pointer in hist[sample].items():\n",
    "        print(hist_pointer)\n",
    "        hist_value = hist_pointer.GetValue()\n",
    "        \n",
    "        hist_value.SetName(\"{}___{}___{}___{}___{}\".format(era, channel, process, name, syst))\n",
    "        print(hist_value)\n",
    "        hist_value.Write()\n",
    "\n",
    "    outFile.Close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16ec3f98",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  },
  "sparkconnect": {
   "bundled_options": [],
   "list_of_options": []
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
