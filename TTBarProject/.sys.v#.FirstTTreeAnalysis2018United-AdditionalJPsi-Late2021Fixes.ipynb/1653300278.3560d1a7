{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "hawaiian-importance",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Welcome to JupyROOT 6.24/06\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Warning in <RTaskArenaWrapper>: CPU Bandwith Control Active. Proceeding with 4 threads accordingly\n"
     ]
    }
   ],
   "source": [
    "import ROOT\n",
    "import glob\n",
    "import numpy as np\n",
    "import os\n",
    "ROOT.gROOT.ProcessLine(\".L FTFunctions.cpp\")\n",
    "ROOT.gInterpreter.Declare(\"\"\"\n",
    "    const UInt_t barWidth = 60;\n",
    "    ULong64_t processed = 0, totalEvents = 0;\n",
    "    std::string progressBar;\n",
    "    std::mutex barMutex; \n",
    "    auto registerEvents = [](ULong64_t nIncrement) {totalEvents += nIncrement;};\n",
    "    ROOT::RDF::RResultPtr<ULong64_t> AddProgressBar(ROOT::RDF::RNode df, int everyN=10000, int totalN=100000) {\n",
    "        registerEvents(totalN);\n",
    "        auto c = df.Count();\n",
    "        c.OnPartialResultSlot(everyN, [everyN] (unsigned int slot, ULong64_t &cnt){\n",
    "            std::lock_guard<std::mutex> l(barMutex);\n",
    "            processed += everyN; //everyN captured by value for this lambda\n",
    "            progressBar = \"[\";\n",
    "            for(UInt_t i = 0; i < static_cast<UInt_t>(static_cast<Float_t>(processed)/totalEvents*barWidth); ++i){\n",
    "                progressBar.push_back('|');\n",
    "            }\n",
    "            // escape the '\\' when defined in python string\n",
    "            std::cout << \"\\\\r\" << std::left << std::setw(barWidth) << progressBar << \"] \" << processed << \"/\" << totalEvents << std::flush;\n",
    "        });\n",
    "        return c;\n",
    "    }\n",
    "\"\"\")\n",
    "# Enables multithreading\n",
    "useRange = False\n",
    "if not useRange:\n",
    "    nThreads = 8\n",
    "    ROOT.ROOT.EnableImplicitMT(nThreads)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "nominated-resource",
   "metadata": {},
   "outputs": [],
   "source": [
    "listOfFilesData = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/SingleMuon/*/*.root\")\n",
    "listOfFilesMonteCarloTTToSemiLeptonic = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloTTTo2L2Nu = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTTo2L2Nu_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloWJetsToLNu = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/WJetsToLNu_TuneCP5_13TeV-madgraphMLM-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloST_tW_top = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/ST_tW_top_5f_inclusiveDecays_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloST_tchannel_top = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/ST_t-channel_top_4f_InclusiveDecays_TuneCP5_13TeV-powheg-madspin-pythia8/*/*.root\")\n",
    "\n",
    "listOfFilesMonteCarloTTToSemiLeptonic = listOfFilesMonteCarloTTToSemiLeptonic[0:1]\n",
    "listOfFilesMonteCarloTTTo2L2Nu = listOfFilesMonteCarloTTTo2L2Nu[0:1]\n",
    "listOfFilesMonteCarloWJetsToLNu = listOfFilesMonteCarloWJetsToLNu[0:1]\n",
    "listOfFilesMonteCarloST_tW_top = listOfFilesMonteCarloST_tW_top[0:1]\n",
    "listOfFilesMonteCarloST_tchannel_top = listOfFilesMonteCarloST_tchannel_top[0:1]\n",
    "\n",
    "dictOfListOfFiles = {\"Data\" : listOfFilesData, \"MonteCarloTTToSemiLeptonic\" : listOfFilesMonteCarloTTToSemiLeptonic, \"MonteCarloTTTo2L2Nu\" : listOfFilesMonteCarloTTTo2L2Nu, \"MonteCarloWJetsToLNu\" : listOfFilesMonteCarloWJetsToLNu, \"MonteCarloST_tW_top\" : listOfFilesMonteCarloST_tW_top, \"MonteCarloST_tchannel_top\" : listOfFilesMonteCarloST_tchannel_top} "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "international-panic",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<cppyy.gbl.ROOT.RDF.RResultPtr<ROOT::RDF::RCutFlowReport> object at 0xb263280>\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Warning in <TClass::Init>: no dictionary for class edm::Hash<1> is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ProcessHistory is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ProcessConfiguration is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ParameterSetBlob is available\n",
      "Warning in <TClass::Init>: no dictionary for class __pair_base<edm::Hash<1>,edm::ParameterSetBlob> is available\n",
      "Warning in <TClass::Init>: no dictionary for class pair<edm::Hash<1>,edm::ParameterSetBlob> is available\n"
     ]
    }
   ],
   "source": [
    "chain = {}\n",
    "meta = {}\n",
    "rdf = {}\n",
    "mrdf = {}\n",
    "nevents = {}\n",
    "sumweight = {}\n",
    "neventsVal = {}\n",
    "\n",
    "\n",
    "\n",
    "rdfPassedIsolatedMuonTrigger = {}\n",
    "rdfIsolatedMuonNoHighWeights = {}\n",
    "rdfIsolatedMuonTriggersAndMasks = {}\n",
    "rdfIsolatedMuonFourMomentum = {}\n",
    "\n",
    "rdfPassedIsolatedElectronTrigger = {}\n",
    "rdfIsolatedElectronNoHighWeights = {}\n",
    "rdfIsolatedElectronTriggersAndMasks = {}\n",
    "rdfIsolatedElectronFourMomentum = {}\n",
    "\n",
    "rdfPassedDimuonTrigger = {}\n",
    "rdfDimuonNoHighWeights = {}\n",
    "rdfDimuonTriggersAndMasks = {}\n",
    "rdfDimuonFourMomentum = {}\n",
    "\n",
    "rdfPassedDielectronTrigger = {}\n",
    "rdfDielectronNoHighWeights = {}\n",
    "rdfDielectronTriggersAndMasks = {}\n",
    "rdfDielectronFourMomentum = {}\n",
    "\n",
    "rdfPassedMuonElectronTrigger = {}\n",
    "rdfMuonElectronNoHighWeights = {}\n",
    "rdfMuonElectronTriggersAndMasks = {}\n",
    "rdfDielectronFourMomentum = {}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#rdfPassedMuonTrigger = {}\n",
    "#rdfMuonNoHighWeights = {}\n",
    "#rdfMuonTriggersAndMasks = {}\n",
    "#rdfMuonFourMomentum = {}\n",
    "\n",
    "#rdfLeadingMuon = {}\n",
    "rdfJPsiMuons = {}\n",
    "\n",
    "\n",
    "rdfOnePlusMuons = {}\n",
    "\n",
    "\n",
    "\n",
    "rdfJetVariables = {}\n",
    "rdfTwoPlusJets = {}\n",
    "rdfNoMuTrigger = {}\n",
    "rdfmuOneBTaggedJet = {}\n",
    "rdfmu = {}\n",
    "rdfOtherMuons = {}\n",
    "rdfAllMuons = {}\n",
    "\n",
    "\n",
    "hist = {}\n",
    "report = {}\n",
    "\n",
    "\n",
    "nparray = {}\n",
    "nparraynode = {}\n",
    "\n",
    "# Muon_pfIsoId is PFIso ID from miniAOD selector (1=PFIsoVeryLoose, 2=PFIsoLoose, 3=PFIsoMedium, 4=PFIsoTight, 5=PFIsoVeryTight, 6=PFIsoVeryVeryTight)\n",
    "IsolatedMuMask = \"Muon_pt > 30 && abs(Muon_eta) < 2.4 && Muon_mediumId == true && Muon_pfIsoId >= 4\"\n",
    "IsolatedElectronMask = \"\"\n",
    "DimuonMask = \"\"\n",
    "DielectronMask = \"\"\n",
    "MuonElectronMask = \"\"\n",
    "JetMask = \"ROOT::VecOps::RVec<Int_t> jmask = (Jet_pt >= 30 && abs(Jet_eta) <= 2.5 && Jet_jetId >= 2); \"\\\n",
    "                          \"for(int i=0; i < IsolatedMuon_pt.size(); ++i){\"\\\n",
    "                              \"ROOT::VecOps::RVec<Float_t> dr;\"\\\n",
    "                              \"for(int j=0; j < jmask.size(); ++j){\"\\\n",
    "                                  \"dr.push_back(ROOT::VecOps::DeltaR(Jet_eta.at(j), IsolatedMuon_eta.at(i), Jet_phi.at(j), IsolatedMuon_phi.at(i)));}\"\\\n",
    "                                  \"jmask = jmask && dr >= 0.4;\"\\\n",
    "                                  \"dr.clear();}\"\\\n",
    "                          \"return jmask;\"\n",
    "JPsiCandidateMask = \"Muon_pt > 3 && abs(Muon_eta) <= 2.4 && Muon_mediumId == true && isolated_mu_mask == false\"\n",
    "\n",
    "for sample, fileList in dictOfListOfFiles.items():\n",
    "    \n",
    "    if sample == 'Data':\n",
    "        vecList = ROOT.std.vector(str)()\n",
    "\n",
    "        for element in dictOfListOfFiles['Data']:\n",
    "            vecList.push_back(element)\n",
    "\n",
    "        rdf['Data'] = ROOT.ROOT.RDataFrame(\"Events\", vecList)    \n",
    "\n",
    "        print(rdf['Data'].Report())\n",
    "        mrdf['Data'] = ROOT.ROOT.RDataFrame(\"Runs\", vecList)\n",
    "        \n",
    "        if useRange:\n",
    "            rdf['Data'] = rdf['Data'].Range(5000)\n",
    "            nrange = 5000\n",
    "            printcode = ' if(rdfentry_ % 5000 == 0) { std::cout << \"Processed entry \" << rdfentry_ << \"/' + str(nrange) + '\" << std::endl; } return rdfentry_;'\n",
    "            print(\"Data run\")\n",
    "            rdf['Data'] = rdf['Data'].Define(\"my_rdfentry\", printcode)\n",
    "            \n",
    "\n",
    "        \n",
    "    else:\n",
    "        chain[sample] = ROOT.TChain(\"Events\")\n",
    "        meta[sample] = ROOT.TChain(\"Runs\")\n",
    "\n",
    "        for file in fileList:\n",
    "            \n",
    "            chain[sample].Add(file)\n",
    "            meta[sample].Add(file)\n",
    "\n",
    "        rdf[sample] = ROOT.ROOT.RDataFrame(chain[sample])\n",
    "        mrdf[sample] = ROOT.ROOT.RDataFrame(meta[sample])\n",
    "        \n",
    "        if useRange:\n",
    "            rdf[sample] = rdf[sample].Range(5000)\n",
    "            \n",
    "            printcode = ' if(rdfentry_ % 5000 == 0) { std::cout << \"Processed entry \" << rdfentry_ << \" \" << rdfslot_ << std::endl; } return rdfentry_;'\n",
    "            print(\"MC run\")\n",
    "            rdf[sample] = rdf[sample].Define(\"my_rdfentry\", printcode)\n",
    "        \n",
    "        nevents[sample] = mrdf[sample].Sum(\"genEventCount\")\n",
    "        sumweight[sample] = mrdf[sample].Sum(\"genEventSumw\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "paperback-video",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Semileptonic ttbar xsection: 364.3109\n",
    "#Single mu trigger for 2017 (B,C,D,E,F): \"HLT_IsoMu27\"\n",
    "#\"HLT_Ele35_WPTight_Gsf\"\n",
    "#lumiDict = {\"2017\": 41.53, \"2018\": 59.97}\n",
    "wgtFormula = {}\n",
    "\n",
    "# wgtFormula used to weight each event\n",
    "# XS = Literature Cross section of the process of interest (in picobarnes; the 1000 converts to femotobarnes), lumi = presumed luminosity of the data one is normalizing against; XS * lumi = # of expected events;\n",
    "# genWeight = quantity stored in every event which comes from the Monte Carlo generator telling you what the value of the generated event is (usually close to 1); it can be + or -; it also contains matching\n",
    "#     effeciency; tells you the Monte Carlo defined value of the event\n",
    "# sW = sum of weights; normalizes the genWeight\n",
    "lumiDict = {\"2018\": 59.97} #  brilcalc lumi --normtag /cvmfs/cms-bril.cern.ch/cms-lumi-pog/Normtags/normtag_PHYSICS.json -u /fb --begin 302031 --end 302663 --hltpath \"HLT_IsoMu27*\"\n",
    "wgtFormula['Data'] = \"1\"\n",
    "wgtFormula['MonteCarloTTToSemiLeptonic'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=364.31, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloTTToSemiLeptonic'].GetValue()))\n",
    "wgtFormula['MonteCarloTTTo2L2Nu'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=87.33, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloTTTo2L2Nu'].GetValue()))\n",
    "wgtFormula['MonteCarloWJetsToLNu'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=61526.7, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloWJetsToLNu'].GetValue()))\n",
    "wgtFormula['MonteCarloST_tW_top'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=71.7, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloST_tW_top'].GetValue()))\n",
    "wgtFormula['MonteCarloST_tchannel_top'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=130, lumi=lumiDict[\"2018\"], sW=float(sumweight['MonteCarloST_tchannel_top'].GetValue()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "better-deputy",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cpp_code = \"\"\"\n",
    "typedef ROOT::VecOps::RVec<Float_t>                        RVec_f;\n",
    "typedef ROOT::VecOps::RVec<Int_t>                          RVec_i;\n",
    "typedef ROOT::VecOps::RVec<Long_t>                         RVec_l;\n",
    "\n",
    "class MatchOppositelyChargedMuons\n",
    "{\n",
    "    private:\n",
    "        RVec_f Paired_Muon_pt;\n",
    "        RVec_f Paired_Muon_eta;\n",
    "        RVec_f Paired_Muon_phi;\n",
    "        RVec_f Paired_Muon_mass;\n",
    "        RVec_i Paired_Muon_charge;\n",
    "        long Paired_EventNumber;\n",
    "        int FlagPair;\n",
    "        RVec_f Isolated_Muon_pt;\n",
    "        RVec_f Isolated_Muon_eta;\n",
    "        RVec_f Isolated_Muon_phi;\n",
    "        RVec_f Isolated_Muon_mass;\n",
    "        RVec_i Isolated_Muon_charge;\n",
    "\n",
    "\n",
    "    public:\n",
    "    MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair);\n",
    "        MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge);\n",
    "        RVec_f InvariantMassCalculator();\n",
    "        RVec_f OppositelyChargedMuonInvariantMassCalculator();\n",
    "        RVec_f ThreeMuonInvariantMassCalculator();\n",
    "        RVec_f DeltaEtaCalculator();\n",
    "        RVec_f DeltaPhiCalculator();\n",
    "        RVec_f DeltaRCalculator();\n",
    "        int ReturnFlagPair();\n",
    "};\n",
    "\n",
    "MatchOppositelyChargedMuons::MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair)\n",
    "{\n",
    "    this->Paired_Muon_pt = Paired_Muon_pt;\n",
    "    this->Paired_Muon_eta = Paired_Muon_eta;\n",
    "    this->Paired_Muon_phi = Paired_Muon_phi;\n",
    "    this->Paired_Muon_mass = Paired_Muon_mass;\n",
    "    this->Paired_Muon_charge = Paired_Muon_charge;\n",
    "    this->Paired_EventNumber = Paired_EventNumber;\n",
    "    this->FlagPair = FlagPair;\n",
    "    this->Isolated_Muon_pt = {};\n",
    "    this->Isolated_Muon_eta = {};\n",
    "    this->Isolated_Muon_phi = {};\n",
    "    this->Isolated_Muon_mass = {};\n",
    "    this->Isolated_Muon_charge = {};\n",
    "}\n",
    "\n",
    "MatchOppositelyChargedMuons::MatchOppositelyChargedMuons(RVec_f Paired_Muon_pt, RVec_f Paired_Muon_eta, RVec_f Paired_Muon_phi, RVec_f Paired_Muon_mass, RVec_i Paired_Muon_charge, long Paired_EventNumber, int FlagPair, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge)\n",
    "{\n",
    "    this->Paired_Muon_pt = Paired_Muon_pt;\n",
    "    this->Paired_Muon_eta = Paired_Muon_eta;\n",
    "    this->Paired_Muon_phi = Paired_Muon_phi;\n",
    "    this->Paired_Muon_mass = Paired_Muon_mass;\n",
    "    this->Paired_Muon_charge = Paired_Muon_charge;\n",
    "    this->Paired_EventNumber = Paired_EventNumber;\n",
    "    this->FlagPair = FlagPair;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "}\n",
    "\n",
    "\n",
    "/* This function matches each muon with oppositely charged muons. */\n",
    "RVec_f MatchOppositelyChargedMuons::OppositelyChargedMuonInvariantMassCalculator()\n",
    "{ \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f InvariantMasses {};\n",
    "    \n",
    "    float im = 0;\n",
    " \n",
    "    /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "    for(int i = 0; i < this->Paired_Muon_charge.size(); i++)\n",
    "    {    \n",
    "\n",
    "        FirstMuonCharge = this->Paired_Muon_charge[i];\n",
    "        \n",
    "        /* If charges are opposite, calculate the invariant mass of them */\n",
    "        for(int j = i+1; j < this->Paired_Muon_charge.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->Paired_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {\n",
    "                pt.push_back(Paired_Muon_pt[i]);\n",
    "                eta.push_back(Paired_Muon_eta[i]);\n",
    "                phi.push_back(Paired_Muon_phi[i]);\n",
    "                mass.push_back(Paired_Muon_mass[i]);\n",
    "                    \n",
    "                pt.push_back(Paired_Muon_pt[j]);\n",
    "                eta.push_back(Paired_Muon_eta[j]);\n",
    "                phi.push_back(Paired_Muon_phi[j]);\n",
    "                mass.push_back(Paired_Muon_mass[j]);\n",
    "                    \n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                \n",
    "                InvariantMasses.push_back(im);\n",
    "                \n",
    "                this->FlagPair = 1;\n",
    "                    \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return InvariantMasses;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::ThreeMuonInvariantMassCalculator()\n",
    "{ \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f InvariantMasses {};\n",
    "    \n",
    "    float im = 0;\n",
    " \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "    \n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->Paired_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->Paired_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->Paired_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->Paired_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {\n",
    "                    pt.push_back(Paired_Muon_pt[i]);\n",
    "                    eta.push_back(Paired_Muon_eta[i]);\n",
    "                    phi.push_back(Paired_Muon_phi[i]);\n",
    "                    mass.push_back(Paired_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(Paired_Muon_pt[j]);\n",
    "                    eta.push_back(Paired_Muon_eta[j]);\n",
    "                    phi.push_back(Paired_Muon_phi[j]);\n",
    "                    mass.push_back(Paired_Muon_mass[j]);\n",
    "                    \n",
    "                    pt.push_back(Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(Isolated_Muon_mass[k]);\n",
    "\n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "\n",
    "                    InvariantMasses.push_back(im);\n",
    "\n",
    "                    this->FlagPair = 1;\n",
    "\n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return InvariantMasses;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::DeltaEtaCalculator()\n",
    "{ \n",
    "    float DeltaEtaIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaEtaRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_eta.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->Paired_Muon_eta.size(); j++)\n",
    "        {    \n",
    "                    DeltaEtaIndividual = this->Isolated_Muon_eta[i] - this->Paired_Muon_eta[j];\n",
    "\n",
    "                    DeltaEtaRVec.push_back(DeltaEtaIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaEtaRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::DeltaPhiCalculator()\n",
    "{ \n",
    "    RVec_f PhiAll {};\n",
    "    RVec_f PhiJPsi {};\n",
    "    \n",
    "    RVec_f DeltaPhiIndividual {};\n",
    "    \n",
    "    RVec_f DeltaPhiRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->Paired_Muon_phi.size(); j++)\n",
    "        {    \n",
    "\n",
    "                    PhiAll.push_back(this->Isolated_Muon_phi[i]);\n",
    "\n",
    "                    PhiJPsi.push_back(this->Paired_Muon_phi[j]);\n",
    "\n",
    "                    DeltaPhiIndividual = ROOT::VecOps::DeltaPhi(PhiAll, PhiJPsi);\n",
    "\n",
    "                    for(int k = 0; k < DeltaPhiIndividual.size(); k++)\n",
    "                    {\n",
    "                        DeltaPhiRVec.push_back(DeltaPhiIndividual[k]);\n",
    "                    }\n",
    "\n",
    "                    PhiAll.clear();\n",
    "                    PhiJPsi.clear();\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaPhiRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MatchOppositelyChargedMuons::DeltaRCalculator()\n",
    "{ \n",
    "    RVec_f EtaAll {};\n",
    "    RVec_f PhiAll {};\n",
    "    RVec_f EtaJPsi {};\n",
    "    RVec_f PhiJPsi {};\n",
    "    \n",
    "    RVec_f DeltaRIndividual {};\n",
    "    \n",
    "    RVec_f DeltaRRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->Paired_Muon_phi.size(); j++)\n",
    "        {    \n",
    "                    EtaAll.push_back(this->Isolated_Muon_eta[i]);\n",
    "                    PhiAll.push_back(this->Isolated_Muon_phi[i]);\n",
    "                    \n",
    "                    EtaJPsi.push_back(this->Paired_Muon_eta[j]);\n",
    "                    PhiJPsi.push_back(this->Paired_Muon_phi[j]);\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaAll, EtaJPsi, PhiAll, PhiJPsi);\n",
    "\n",
    "                    for(int k = 0; k < DeltaRIndividual.size(); k++)\n",
    "                    {\n",
    "                        DeltaRRVec.push_back(DeltaRIndividual[k]);\n",
    "                    }\n",
    "\n",
    "                    EtaAll.clear();\n",
    "                    PhiAll.clear();\n",
    "                    EtaJPsi.clear();\n",
    "                    PhiJPsi.clear();\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaRRVec;\n",
    "}\n",
    "\n",
    "\n",
    "int MatchOppositelyChargedMuons::ReturnFlagPair()\n",
    "{\n",
    "    return this->FlagPair;\n",
    "}\n",
    "\"\"\"\n",
    "\n",
    "ROOT.gInterpreter.Declare(cpp_code)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ce5dd994",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Add dilepton triggers (e/mu, e/e, mu/mu where needed)\n",
    "def MuonLeptonSelection():\n",
    "\n",
    "    for sample in dictOfListOfFiles:       \n",
    "\n",
    "        rdfPassedTrigger[sample] = rdf[sample].Filter(\"HLT_IsoMu24 == true\", \"HLTTriggerSingleMuonTrigger\")\\\n",
    "            .Define(\"LumiXS\",wgtFormula[sample])\\\n",
    "            .Define(\"isolated_mu_mask\", IsolatedMuMask)\\\n",
    "            .Define(\"jpsi_mu_candidate_mask\", JPsiCandidateMask)\n",
    "\n",
    "        if sample == 'Data':\n",
    "            rdfNoHighWeights[sample] = rdfPassedTrigger[sample]\n",
    "\n",
    "        # Change criteria to nothing below or above 4 standard deviations from the mean\n",
    "        else:\n",
    "            rdfNoHighWeights[sample] = rdfPassedTrigger[sample].Filter(\"genWeight < 1000\", \"No Abnormal Weights\")\n",
    "\n",
    "        rdfWithFourMomentum[sample] = rdfNoHighWeights[sample]\\\n",
    "            .Define(\"Muon_FourMomentum\", \"auto fourVecs = ROOT::VecOps::Construct<ROOT::Math::PtEtaPhiMVector>(Muon_pt, Muon_eta, Muon_phi, Muon_mass); return fourVecs;\")\\\n",
    "            .Define(\"IsolatedMuon_pt\", \"Muon_pt[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedMuon_eta\", \"Muon_eta[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedMuon_phi\", \"Muon_phi[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedMuon_mass\", \"Muon_mass[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedMuon_charge\", \"Muon_charge[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedMuon_four_momentum\", \"Muon_FourMomentum[isolated_mu_mask]\")\\\n",
    "            .Define(\"LeadingIsolatedMuon_pt\", \"IsolatedMuon_pt.at(0, -10)\")\\\n",
    "            .Define(\"LeadingIsolatedMuon_eta\", \"IsolatedMuon_eta.at(0, -10)\")\\\n",
    "            .Define(\"LeadingIsolatedMuon_phi\", \"IsolatedMuon_phi.at(0, -5)\")\\\n",
    "            .Define(\"LeadingIsolatedMuon_mass\", \"IsolatedMuon_mass.at(0, -2.71)\")\\\n",
    "            .Define(\"LeadingIsolatedMuon_charge\", \"IsolatedMuon_charge.at(0, -5)\")\\\n",
    "\n",
    "    return rdfWithFourMomentum"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "54881930",
   "metadata": {},
   "outputs": [],
   "source": [
    "rdfWithFourMomentum = MuonLeptonSelection()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5f57c03a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Change all muon things to electon things\n",
    "def ElectronLeptonSelection():\n",
    "\n",
    "    for sample in dictOfListOfFiles:       \n",
    "\n",
    "        rdfPassedTrigger[sample] = rdf[sample].Filter(\"HLT_Ele32_WPTight_Gsf_v == true\", \"HLTTriggerSingleElectronTrigger\")\\\n",
    "            .Define(\"LumiXS\",wgtFormula[sample])\\\n",
    "            .Define(\"isolated_electron_mask\", IsolatedMuonMask)\n",
    "            #.Define(\"jpsi_mu_candidate_mask\", JPsiCandidateMask)\n",
    "\n",
    "        if sample == 'Data':\n",
    "            rdfNoHighWeights[sample] = rdfPassedTrigger[sample]\n",
    "\n",
    "        # Change criteria to nothing below or above 4 standard deviations from the mean\n",
    "        else:\n",
    "            rdfNoHighWeights[sample] = rdfPassedTrigger[sample].Filter(\"genWeight < 1000\", \"No High Weights\")\n",
    "\n",
    "        rdfWithFourMomentum[sample] = rdfNoHighWeights[sample]\\\n",
    "            .Define(\"Electron_FourMomentum\", \"auto fourVecs = ROOT::VecOps::Construct<ROOT::Math::PtEtaPhiMVector>(Electron_pt, Electron_eta, Electron_phi, Electron_mass); return fourVecs;\")\\\n",
    "            .Define(\"IsolatedElectron_pt\", \"Electron_pt[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedElectron_eta\", \"Electron_eta[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedElectron_phi\", \"Electron_phi[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedElectron_mass\", \"Electron_mass[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedElectron_charge\", \"Electron_charge[isolated_mu_mask]\")\\\n",
    "            .Define(\"IsolatedElectron_four_momentum\", \"Electron_FourMomentum[isolated_mu_mask]\")\\\n",
    "            .Define(\"LeadingIsolatedElectron_pt\", \"IsolatedElectron_pt.at(0, -10)\")\\\n",
    "            .Define(\"LeadingIsolatedElectron_eta\", \"IsolatedElectron_eta.at(0, -10)\")\\\n",
    "            .Define(\"LeadingIsolatedElectron_phi\", \"IsolatedElectron_phi.at(0, -5)\")\\\n",
    "            .Define(\"LeadingIsolatedElectron_mass\", \"IsolatedElectron_mass.at(0, -2.71)\")\\\n",
    "            .Define(\"LeadingIsolatedElectron_charge\", \"IsolatedElectron_charge.at(0, -5)\")\\\n",
    "\n",
    "    return rdfWithFourMomentum"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b4631d4b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Call the ElectronLeptonSelection function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "0ea54eba",
   "metadata": {},
   "outputs": [],
   "source": [
    "def JetSelection():\n",
    "    rdfJetVariables[sample] = rdfSubleadingMuon[sample]\\\n",
    "        .Define(\"jet_mask\", JetMask)\\\n",
    "        .Define(\"MediumBJetMask\", \"Jet_btagDeepFlavB > 0.3033 && jet_mask\" )\\\n",
    "        .Define(\"MTofMETandMu\", \"FTA::transverseMassMET(IsolatedMuon_pt, IsolatedMuon_phi, IsolatedMuon_mass, MET_pt, MET_phi)\")\\\n",
    "        .Define(\"Num_Jets\", \"Jet_pt[jet_mask].size()\")\\\n",
    "        .Define(\"SJet1_pt\", \"Jet_pt[jet_mask].size() > 0 ? Jet_pt[jet_mask].at(0) : -500\")\\\n",
    "        .Define(\"SJet2_pt\", \"Jet_pt[jet_mask].size() > 1 ? Jet_pt[jet_mask].at(1) : -500\")\\\n",
    "        .Define(\"SJet1_eta\", \"Jet_eta[jet_mask].size() > 0 ? Jet_eta[jet_mask].at(0) : 500\")\\\n",
    "        .Define(\"SJet2_eta\", \"Jet_eta[jet_mask].size() > 1 ? Jet_eta[jet_mask].at(1) : 500\")\\\n",
    "        .Define(\"SJet1_phi\", \"Jet_phi[jet_mask].size() > 0 ? Jet_phi[jet_mask].at(0) : 500\")\\        \n",
    "        .Define(\"SJet2_phi\", \"Jet_phi[jet_mask].size() > 1 ? Jet_phi[jet_mask].at(1) : 500\")\\\n",
    "        .Define(\"SJet_btagDeepFlavB\", \"Jet_btagDeepFlavB[jet_mask]\")\\\n",
    "        .Define(\"Num_BTaggedJets\", \"Sum(MediumBJetMask)\")\\\n",
    "        .Define(\"Ht\", \"Sum(Jet_pt[jet_mask])\")\n",
    "\n",
    "#     rdfTwoPlusJets[sample] = rdfJetVariables[sample].Filter(\"Num_Jets >= 4\", \"At Least Four Jets\")\\\n",
    "#         .Define(\"DeepJetB\", \"Jet_pt[jet_mask].size() > 0 ? Jet_btagDeepFlavB[jet_mask].at(0) : 0\")\\\n",
    "#         .Define(\"Num_Muons\", \"Muon_pt[isolated_mu_mask].size()\")\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3adbd451",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "30a9ba45",
   "metadata": {},
   "outputs": [],
   "source": [
    "def JPsiSelection():\n",
    "    \n",
    "    for sample in dictOfListOfFiles:\n",
    "        print(rdfWithFourMomentum[sample].GetDefinedColumnNames())\n",
    "        rdfJPsiMuons[sample] = rdfWithFourMomentum[sample].Filter(\"Sum(jpsi_mu_candidate_mask) >= 2\", \"JPsi Candidate\")\\\n",
    "            .Define(\"JPsiCandidate_packedIndices\", \"ROOT::VecOps::Combinations(Muon_pt[jpsi_mu_candidate_mask], 2)\")\\\n",
    "            .Define(\"JPsiCandidate_idx0\", \"JPsiCandidate_packedIndices[0]\")\\\n",
    "            .Define(\"JPsiCandidate_idx1\",  \"JPsiCandidate_packedIndices[1]\")\\\n",
    "            .Define(\"JPsiCandidate_four_momentum\", \"ROOT::VecOps::Take(Muon_FourMomentum[jpsi_mu_candidate_mask], JPsiCandidate_idx0) + ROOT::VecOps::Take(Muon_FourMomentum[jpsi_mu_candidate_mask], JPsiCandidate_idx1)\")\\\n",
    "            .Define(\"JPsiCandidate_pt\", \"ROOT::VecOps::RVec<double> temp; for (auto p: JPsiCandidate_four_momentum) {temp.push_back(p.Pt());} return temp;\")\\\n",
    "            .Define(\"JPsiCandidate_eta\", \"ROOT::VecOps::RVec<double> temp; for (auto p: JPsiCandidate_four_momentum) {temp.push_back(p.Eta());} return temp;\")\\\n",
    "            .Define(\"JPsiCandidate_phi\", \"ROOT::VecOps::RVec<double> temp; for (auto p: JPsiCandidate_four_momentum) {temp.push_back(p.Phi());} return temp;\")\\\n",
    "            .Define(\"JPsiCandidate_mass\", \"ROOT::VecOps::RVec<double> temp; for (auto p: JPsiCandidate_four_momentum) {temp.push_back(p.M());} return temp;\")\\\n",
    "            .Define(\"JPsiCandidate_charge\", \"ROOT::VecOps::Take(Muon_charge[jpsi_mu_candidate_mask], JPsiCandidate_idx0) + ROOT::VecOps::Take(Muon_charge[jpsi_mu_candidate_mask], JPsiCandidate_idx1)\")\\\n",
    "            .Define(\"DeltaEta\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiCandidate_pt, JPsiCandidate_eta, JPsiCandidate_phi, JPsiCandidate_mass, JPsiCandidate_charge); return c.DeltaEtaCalculator()\")\\\n",
    "            .Define(\"DeltaPhi\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiCandidate_pt, JPsiCandidate_eta, JPsiCandidate_phi, JPsiCandidate_mass, JPsiCandidate_charge); return c.DeltaPhiCalculator()\")\\\n",
    "            .Define(\"DeltaR\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiCandidate_pt, JPsiCandidate_eta, JPsiCandidate_phi, JPsiCandidate_mass, JPsiCandidate_charge); return c.DeltaRCalculator()\")\n",
    "\n",
    "    return rdfJPsiMuons\n",
    "#         .Define(\"JPsiMuons_pt\", \"Muon_pt[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_eta\", \"Muon_eta[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_phi\", \"Muon_phi[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_charge\", \"Muon_charge[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_mass\", \"Muon_mass[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_multiplicity\", \"Muon_pt[jpsi_mu_candidate_mask].size()\")\\\n",
    "#         .Define(\"JPsiMuons_four_momentum\", \"Muon_FourMomentum[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiCandidate_packedIndices\", \"ROOT::VecOps::Combinations(JPsiMuons_pt, 2)\")\\\n",
    "#         .Define(\"JPsiCandidate_FirstMuon\", \"JPsiCandidate_packedIndices[0]\")\\\n",
    "#         .Define(\"JPsiCandidate_SecondMuon\", \"JPsiCandidate_packedIndices[1]\")\\\n",
    "#         .Define(\"InvariantMasses\", \"std::cout << rdfentry_ << std::endl; int FlagPair = -1; auto c = MatchOppositelyChargedMuons(JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge, event, FlagPair); return c.OppositelyChargedMuonInvariantMassCalculator()\")\\\n",
    "#         .Define(\"InvariantMassesAllMuons\", \"std::cout << rdfentry_ << std::endl; int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.ThreeMuonInvariantMassCalculator()\")\\"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "13bc128a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{ \"IsolatedMuon_charge\", \"IsolatedMuon_eta\", \"IsolatedMuon_four_momentum\", \"IsolatedMuon_mass\", \"IsolatedMuon_phi\", \"IsolatedMuon_pt\", \"LeadingIsolatedMuon_charge\", \"LeadingIsolatedMuon_eta\", \"LeadingIsolatedMuon_mass\", \"LeadingIsolatedMuon_phi\", \"LeadingIsolatedMuon_pt\", \"LumiXS\", \"Muon_FourMomentum\", \"isolated_mu_mask\", \"jpsi_mu_candidate_mask\" }\n",
      "{ \"IsolatedMuon_charge\", \"IsolatedMuon_eta\", \"IsolatedMuon_four_momentum\", \"IsolatedMuon_mass\", \"IsolatedMuon_phi\", \"IsolatedMuon_pt\", \"LeadingIsolatedMuon_charge\", \"LeadingIsolatedMuon_eta\", \"LeadingIsolatedMuon_mass\", \"LeadingIsolatedMuon_phi\", \"LeadingIsolatedMuon_pt\", \"LumiXS\", \"Muon_FourMomentum\", \"isolated_mu_mask\", \"jpsi_mu_candidate_mask\" }\n",
      "{ \"IsolatedMuon_charge\", \"IsolatedMuon_eta\", \"IsolatedMuon_four_momentum\", \"IsolatedMuon_mass\", \"IsolatedMuon_phi\", \"IsolatedMuon_pt\", \"LeadingIsolatedMuon_charge\", \"LeadingIsolatedMuon_eta\", \"LeadingIsolatedMuon_mass\", \"LeadingIsolatedMuon_phi\", \"LeadingIsolatedMuon_pt\", \"LumiXS\", \"Muon_FourMomentum\", \"isolated_mu_mask\", \"jpsi_mu_candidate_mask\" }\n",
      "{ \"IsolatedMuon_charge\", \"IsolatedMuon_eta\", \"IsolatedMuon_four_momentum\", \"IsolatedMuon_mass\", \"IsolatedMuon_phi\", \"IsolatedMuon_pt\", \"LeadingIsolatedMuon_charge\", \"LeadingIsolatedMuon_eta\", \"LeadingIsolatedMuon_mass\", \"LeadingIsolatedMuon_phi\", \"LeadingIsolatedMuon_pt\", \"LumiXS\", \"Muon_FourMomentum\", \"isolated_mu_mask\", \"jpsi_mu_candidate_mask\" }\n",
      "{ \"IsolatedMuon_charge\", \"IsolatedMuon_eta\", \"IsolatedMuon_four_momentum\", \"IsolatedMuon_mass\", \"IsolatedMuon_phi\", \"IsolatedMuon_pt\", \"LeadingIsolatedMuon_charge\", \"LeadingIsolatedMuon_eta\", \"LeadingIsolatedMuon_mass\", \"LeadingIsolatedMuon_phi\", \"LeadingIsolatedMuon_pt\", \"LumiXS\", \"Muon_FourMomentum\", \"isolated_mu_mask\", \"jpsi_mu_candidate_mask\" }\n",
      "{ \"IsolatedMuon_charge\", \"IsolatedMuon_eta\", \"IsolatedMuon_four_momentum\", \"IsolatedMuon_mass\", \"IsolatedMuon_phi\", \"IsolatedMuon_pt\", \"LeadingIsolatedMuon_charge\", \"LeadingIsolatedMuon_eta\", \"LeadingIsolatedMuon_mass\", \"LeadingIsolatedMuon_phi\", \"LeadingIsolatedMuon_pt\", \"LumiXS\", \"Muon_FourMomentum\", \"isolated_mu_mask\", \"jpsi_mu_candidate_mask\" }\n"
     ]
    }
   ],
   "source": [
    "rdfJPsiMuons = JPsiSelection()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "352c067b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Make this block a function with the inputs as the nodes we want to attach histograms to(2-17-22)\n",
    "\n",
    "for sample in dictOfListOfFiles:\n",
    "    \n",
    "    if sample not in hist.keys():\n",
    "        hist[sample] = {}\n",
    "        report[sample] = rdf[sample].Report()\n",
    "        #nparraynode[sample] = rdfLeadingMuon[sample]\n",
    "        \n",
    "    if sample == 'Data':\n",
    "        \n",
    "        hist['Data'][\"leading_muon_pt\"] = rdfWithFourMomentum['Data'].Histo1D((\"leading_muon_pt\",\"Leading Muon Transverse Momentum; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\")\n",
    "        hist['Data'][\"leading_muon_eta\"] = rdfWithFourMomentum['Data'].Histo1D((\"leading_muon_eta\", \"Leading Muon Pseudorapidity; Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\")\n",
    "        hist['Data'][\"leading_muon_phi\"] = rdfWithFourMomentum['Data'].Histo1D((\"leading_muon_phi\", \"Leading Muon Angle; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\")\n",
    "        hist['Data'][\"leading_muon_mass\"] = rdfWithFourMomentum['Data'].Histo1D((\"leading_muon_mass\", \"Leading Muon Mass; Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\")\n",
    "        hist['Data'][\"leading_muon_charge\"] = rdfWithFourMomentum['Data'].Histo1D((\"leading_muon_charge\", \"Leading Muon Charge; Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\")\n",
    "        #hist['Data'][\"delta_eta\"] = rdfJPsiMuons['Data'].Histo1D((\"delta_eta\", \"Delta Eta; Delta Eta; Events\",50,0,6),\"DeltaEta\")\n",
    "        #hist['Data'][\"delta_phi\"] = rdfJPsiMuons['Data'].Histo1D((\"delta_phi\", \"Delta Phi; Delta Phi; Events\",50,-3.5,3.5),\"DeltaPhi\")\n",
    "        #hist['Data'][\"delta_r\"] = rdfJPsiMuons['Data'].Histo1D((\"delta_r\", \"Delta R; Delta R; Events\",50,0,6),\"DeltaR\")\n",
    "\n",
    "    else:\n",
    "        \n",
    "        hist[sample][\"leading_muon_pt\"] = rdfWithFourMomentum[sample].Histo1D((sample + \"_\" + \"leading_muon_pt\", \"Monte Carlo \" + sample + \";Leading Muon Transverse Momentum; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\",\"LumiXS\")\n",
    "        hist[sample][\"leading_muon_eta\"] = rdfWithFourMomentum[sample].Histo1D((sample + \"_\" + \"leading_muon_eta\", \"Monte Carlo \" + sample + \";Leading Muon Pseudorapidity; Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\",\"LumiXS\")\n",
    "        hist[sample][\"leading_muon_phi\"] = rdfWithFourMomentum[sample].Histo1D((sample + \"_\" + \"leading_muon_phi\", \"Monte Carlo \" + sample + \";Leading Muon Angle; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\",\"LumiXS\")\n",
    "        hist[sample][\"leading_muon_mass\"] = rdfWithFourMomentum[sample].Histo1D((sample + \"_\" + \"leading_muon_mass\", \"Monte Carlo \" + sample + \";Leading Muon Mass; Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\",\"LumiXS\")\n",
    "        hist[sample][\"leading_muon_charge\"] = rdfWithFourMomentum[sample].Histo1D((sample + \"_\" + \"leading_muon_charge\", \"Monte Carlo \" + sample + \";Leading Muon Charge; Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\",\"LumiXS\")\n",
    "        #hist[sample][\"delta_eta\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_eta\", \"Monte Carlo \" + sample + \";Delta Eta; Delta Eta; Events\",50,0,6),\"DeltaEta\",\"LumiXS\")\n",
    "        #hist[sample][\"delta_phi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_phi\", \"Monte Carlo \" + sample + \";Delta Phi; Delta Phi; Events\",50,-3.5,3.5),\"DeltaPhi\",\"LumiXS\")\n",
    "        #hist[sample][\"delta_r\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_r\", \"Monte Carlo \" + sample + \";Delta R; Delta R; Events\",50,0,6),\"DeltaR\",\"LumiXS\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "89cb3651",
   "metadata": {},
   "outputs": [],
   "source": [
    "# def BTagSelection():\n",
    "#     rdfmuOneBTaggedJet[sample] = rdfTwoPlusJets[sample].Filter(\"Num_BTaggedJets >= 1\", \"At Least One B-Tagged Jet\")\n",
    "#     # This fifth filter keeps only events with no vetoed muons\n",
    "#     rdfmu[sample] = rdfmuOneBTaggedJet[sample].Filter(\"Sum(isolated_mu_veto) == 0\", \"No Vetoed Muons\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "fixed-manor",
   "metadata": {},
   "outputs": [],
   "source": [
    "# # Object selection (masks) and cuts (filters)\n",
    "# # LumiXS is lumi * xs\n",
    "# #.Define(\"Junk\", 'if(rdfentry_ % 200000 == 0){ std::cout << \"Processed \" << rdfentry_ << \" entries on slot \" << rdfslot_ << std::endl;} return rdfentry_;')\n",
    "\n",
    "# # Initial cuts for finding muons, isolated or not.\n",
    "# for sample in dictOfListOfFiles:\n",
    "#     # The first filter determines whether there is a single muon or not.  In addition, mu_mask is defined which will later filter out processes with at least one good, isolated muon. mu_veto\n",
    "#     # is defined which will later filter out events with muons which are vetoed. Also, jpsi_mu_candidate mask is defined and will be later used to filter out possible oppositely charged muon\n",
    "#     # candidates from events with at least one, good, isolated muon.\n",
    "#     rdfTriggersAndMasks[sample] = rdf[sample].Filter(\"HLT_IsoMu27 == true\", \"HLTTriggerSingleMuonTrigger\")\\\n",
    "#         .Define(\"LumiXS\",wgtFormula[sample])\\\n",
    "#         .Define(\"isolated_mu_mask\", \"Muon_pt > 30 && abs(Muon_eta) < 2.4 && Muon_tightId == true && Muon_pfIsoId >= 4\")\\\n",
    "#         .Define(\"isolated_mu_veto\", \"Muon_pt > 10 && abs(Muon_eta) < 2.4 && Muon_looseId == true && Muon_pfIsoId >= 4 && isolated_mu_mask == false\")\\\n",
    "#         .Define(\"jpsi_mu_candidate_mask\", \"Muon_pt > 3 && Muon_mediumId == true && isolated_mu_mask == false\")\n",
    "#     # The second filter keeps all events with at least one good, isolated muon.  In addtion, the pt, eta, etc. of the isolated muon is determined.\n",
    "#     rdfOnePlusMuons[sample] = rdfTriggersAndMasks[sample].Filter(\"Sum(isolated_mu_mask) == 1\", \"Exactly One Good Isolated Muon\")\\\n",
    "#         .Define(\"IsolatedMuon_pt\", \"Muon_pt[isolated_mu_mask]\")\\\n",
    "#         .Define(\"IsolatedMuon_eta\", \"Muon_eta[isolated_mu_mask]\")\\\n",
    "#         .Define(\"IsolatedMuon_phi\", \"Muon_phi[isolated_mu_mask]\")\\\n",
    "#         .Define(\"IsolatedMuon_mass\", \"Muon_mass[isolated_mu_mask]\")\\\n",
    "#         .Define(\"IsolatedMuon_charge\", \"Muon_charge[isolated_mu_mask]\")\\\n",
    "#         .Define(\"IsolatedMuon_pfRelIso03_all\", \"Muon_pfRelIso03_all[isolated_mu_mask]\")\\\n",
    "#         .Define(\"IsolatedMuon_pfRelIso03_chg\", \"Muon_pfRelIso03_chg[isolated_mu_mask]\")\\\n",
    "#         .Define(\"IsolatedMuon_pfRelIso04_all\", \"Muon_pfRelIso04_all[isolated_mu_mask]\")\n",
    "#     # No filter here, but criteria for jets are spelled out and the pt, eta, phi, etc. of jets are defined\n",
    "#     rdfJetVariables[sample] = rdfOnePlusMuons[sample]\\\n",
    "#         .Define(\"jet_mask\", \"ROOT::VecOps::RVec<Int_t> jmask = (Jet_pt >= 30 && abs(Jet_eta) <= 2.5 && Jet_jetId >= 2); \"\\\n",
    "#                           \"for(int i=0; i < IsolatedMuon_pt.size(); ++i){\"\\\n",
    "#                               \"ROOT::VecOps::RVec<Float_t> dr;\"\\\n",
    "#                               \"for(int j=0; j < jmask.size(); ++j){\"\\\n",
    "#                                   \"dr.push_back(ROOT::VecOps::DeltaR(Jet_eta.at(j), IsolatedMuon_eta.at(i), Jet_phi.at(j), IsolatedMuon_phi.at(i)));}\"\\\n",
    "#                                   \"jmask = jmask && dr >= 0.4;\"\\\n",
    "#                                   \"dr.clear();}\"\\\n",
    "#                           \"return jmask;\")\\\n",
    "#         .Define(\"MediumBJetMask\", \"Jet_btagDeepFlavB > 0.3033 && jet_mask\" )\\\n",
    "#         .Define(\"MTofMETandMu\", \"FTA::transverseMassMET(IsolatedMuon_pt, IsolatedMuon_phi, IsolatedMuon_mass, MET_pt, MET_phi)\")\\\n",
    "#         .Define(\"Num_Jets\", \"Jet_pt[jet_mask].size()\")\\\n",
    "#         .Define(\"SJet1_pt\", \"Jet_pt[jet_mask].size() > 0 ? Jet_pt[jet_mask].at(0) : -500\")\\\n",
    "#         .Define(\"SJet2_pt\", \"Jet_pt[jet_mask].size() > 1 ? Jet_pt[jet_mask].at(1) : -500\")\\\n",
    "#         .Define(\"SJet1_eta\", \"Jet_eta[jet_mask].size() > 0 ? Jet_eta[jet_mask].at(0) : 500\")\\\n",
    "#         .Define(\"SJet2_eta\", \"Jet_eta[jet_mask].size() > 1 ? Jet_eta[jet_mask].at(1) : 500\")\\\n",
    "#         .Define(\"SJet1_phi\", \"Jet_phi[jet_mask].size() > 0 ? Jet_phi[jet_mask].at(0) : 500\")\\\n",
    "#         .Define(\"SJet2_phi\", \"Jet_phi[jet_mask].size() > 1 ? Jet_phi[jet_mask].at(1) : 500\")\\\n",
    "#         .Define(\"SJet_btagDeepFlavB\", \"Jet_btagDeepFlavB[jet_mask]\")\\\n",
    "#         .Define(\"Num_BTaggedJets\", \"Sum(MediumBJetMask)\")\\\n",
    "#         .Define(\"Ht\", \"Sum(Jet_pt[jet_mask])\")\n",
    "#     # This third filter leaves only events with at least 4 jets\n",
    "#     rdfTwoPlusJets[sample] = rdfJetVariables[sample].Filter(\"Num_Jets >= 4\", \"At Least Four Jets\")\\\n",
    "#         .Define(\"DeepJetB\", \"Jet_pt[jet_mask].size() > 0 ? Jet_btagDeepFlavB[jet_mask].at(0) : 0\")\\\n",
    "#         .Define(\"Num_Muons\", \"Muon_pt[isolated_mu_mask].size()\")\n",
    "#     # This fourth filter leaves only events with at least 1 b-tagged jet\n",
    "#     rdfmuOneBTaggedJet[sample] = rdfTwoPlusJets[sample].Filter(\"Num_BTaggedJets >= 1\", \"At Least One B-Tagged Jet\")\n",
    "#     # This fifth filter keeps only events with no vetoed muons\n",
    "#     rdfmu[sample] = rdfmuOneBTaggedJet[sample].Filter(\"Sum(isolated_mu_veto) == 0\", \"No Vetoed Muons\")\n",
    "    \n",
    "#     # This sixth filter keeps events with at least one jpsi candidate (should this be upped to 2?).  This is on top of all the prvious criteria.  Of the muons which have made it this far, we apply the\n",
    "#     # jpsi_mu_candidate_mask to determine which are J/Psi-related muons.\n",
    "#     rdfOtherMuons[sample] = rdfmu[sample].Filter(\"Sum(jpsi_mu_candidate_mask) >= 2\", \"JPsi Candidate\")\\\n",
    "#         .Define(\"JPsiMuons_pt\", \"Muon_pt[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_eta\", \"Muon_eta[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_phi\", \"Muon_phi[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_charge\", \"Muon_charge[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_mass\", \"Muon_mass[jpsi_mu_candidate_mask]\")\\\n",
    "#         .Define(\"JPsiMuons_multiplicity\", \"Muon_pt[jpsi_mu_candidate_mask].size()\")\\\n",
    "#         .Define(\"InvariantMasses\", \"std::cout << rdfentry_ << std::endl; int FlagPair = -1; auto c = MatchOppositelyChargedMuons(JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge, event, FlagPair); return c.OppositelyChargedMuonInvariantMassCalculator()\")\\\n",
    "#         .Define(\"InvariantMassesAllMuons\", \"std::cout << rdfentry_ << std::endl; int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.ThreeMuonInvariantMassCalculator()\")\\\n",
    "#         .Define(\"DeltaEta\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.DeltaEtaCalculator()\")\\\n",
    "#         .Define(\"DeltaPhi\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.DeltaPhiCalculator()\")\\\n",
    "#         .Define(\"DeltaR\", \"int FlagPair = -1; auto c = MatchOppositelyChargedMuons(IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, event, FlagPair, JPsiMuons_pt, JPsiMuons_eta, JPsiMuons_phi, JPsiMuons_mass, JPsiMuons_charge); return c.DeltaRCalculator()\")\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "36c70404",
   "metadata": {},
   "outputs": [],
   "source": [
    "# pt = ROOT.VecOps.RVec['float']([1,2,3,4,5])\n",
    "# eta = ROOT.VecOps.RVec['float']([1.5,2.5,3.5,4.5,5.5])\n",
    "# phi = ROOT.VecOps.RVec['float']([1.6,1.7,1.8,1.9,2.0])\n",
    "# mass = ROOT.VecOps.RVec['float']([5,4,3,2,1])\n",
    "# charge = ROOT.VecOps.RVec['int']([-1,1,-1,1,-1])\n",
    "# event = 12\n",
    "# FlagPair = -1\n",
    "# v = ROOT.MatchOppositelyChargedMuons(pt, eta, phi, mass, charge, event, FlagPair)\n",
    "# print(v.OppositelyChargedMuonInvariantMassCalculator())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "sixth-northern",
   "metadata": {},
   "outputs": [],
   "source": [
    "# for sample in dictOfListOfFiles:\n",
    "    \n",
    "#     if sample not in hist.keys():\n",
    "#         hist[sample] = {}\n",
    "#         stats[sample] = {}\n",
    "#         report[sample] = rdf[sample].Report()\n",
    "        \n",
    "#     #stats[sample][\"countercode\"] = rdf[sample].Min('my_rdfentry')\n",
    "        \n",
    "#     if sample == 'Data':\n",
    "        \n",
    "#         hist['Data'][\"isolated_mu_pt\"] = rdfmu['Data'].Histo1D((\"mu_pt\",\"Muon Transverse Momentum; Pt (GeV);Events\",100,20,220),\"IsolatedMuon_pt\")\n",
    "#         hist['Data'][\"isolated_mu_eta\"] = rdfmu['Data'].Histo1D((\"mu_eta\", \"Muon Pseudorapidity; Eta; Events\",100,-3,3),\"IsolatedMuon_eta\")\n",
    "#         hist['Data'][\"isolated_mu_phi\"] = rdfmu['Data'].Histo1D((\"mu_phi\", \"Muon Angle; Phi (Radians); Events\",100,-3.5,3.5),\"IsolatedMuon_phi\")\n",
    "#         hist['Data'][\"jet1_pt\"] = rdfmu['Data'].Histo1D((\"jet1_pt\", \"Jet Transverse Momentum for Leading Jet; Pt (GeV); Events\", 100, 20, 200), \"SJet1_pt\")\n",
    "#         hist['Data'][\"jet2_pt\"] = rdfmu['Data'].Histo1D((\"jet2_pt\", \"Jet Transverse Momentum for Subleading Jet; Pt (GeV); Events\", 100, 20, 200), \"SJet2_pt\")\n",
    "#         hist['Data'][\"jet1_eta\"] = rdfmu['Data'].Histo1D((\"jet1_eta\", \"Jet Pseudorapidity for Leading Jet; Eta; Events\", 100, -3, 3), \"SJet1_eta\")\n",
    "#         hist['Data'][\"jet2_eta\"] = rdfmu['Data'].Histo1D((\"jet2_eta\", \"Jet Pseudorapidity for Subleading Jet; Eta; Events\", 100, -3, 3), \"SJet2_eta\")\n",
    "#         hist['Data'][\"jet1_phi\"] = rdfmu['Data'].Histo1D((\"jet1_phi\", \"Jet Angle for Leading Jet; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet1_phi\")\n",
    "#         hist['Data'][\"jet2_phi\"] = rdfmu['Data'].Histo1D((\"jet2_phi\", \"Jet Angle for Subleading Jet; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet2_phi\")\n",
    "#         hist['Data'][\"jet_deep\"] = rdfmu['Data'].Histo1D((\"jet_deep\", \"Deep Jet B Discriminator; Discriminant Value; Events\", 100, 0, 1), \"DeepJetB\")\n",
    "#         hist['Data'][\"number_of_jets\"] = rdfmu['Data'].Histo1D((\"number_of_jets\", \"Number of Jets; Number Of Jets; Events\", 20, 0, 20), \"Num_Jets\") \n",
    "#         hist['Data'][\"number_of_muons\"] = rdfmu['Data'].Histo1D((\"number_of_muons\", \"Number of Muons; Number of Muons; Events\", 5, 0, 5), \"Num_Muons\")\n",
    "#         hist['Data'][\"transverse_mass\"] = rdfmu['Data'].Histo1D((\"transverse_mass\", \"Transverse Mass; Transverse Mass (GeV); Events\", 150, 0, 150), \"MTofMETandMu\")\n",
    "#         hist['Data'][\"missing_transverse_momentum\"] = rdfmu['Data'].Histo1D((\"missing_transverse_momentum\", \"Missing Transverse Momentum; Missing Transverse Momentum(GeV); Events\", 150, 0, 300), \"MET_pt\")\n",
    "#         hist['Data'][\"ht\"] = rdfmu['Data'].Histo1D((\"ht\", \"Ht; Ht; Events\", 300, 0, 1500), \"Ht\")\n",
    "#         hist['Data'][\"isolated_muon_pfRelIso03_all\"] = rdfmu['Data'].Histo1D((\"muon_pfRelIso03_all\", \"Muon Pf Rel Iso 03 (All); Muon Pf Rel Iso 03 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_all\")\n",
    "#         hist['Data'][\"isolated_muon_pfRelIso03_chg\"] = rdfmu['Data'].Histo1D((\"muon_pfRelIso03_chg\", \"Muon Pf Rel Iso 03 (Chg); Muon Pf Rel Iso 03 (Chg); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_chg\")\n",
    "#         hist['Data'][\"isolated_muon_pfRelIso04_all\"] = rdfmu['Data'].Histo1D((\"muon_pfRelIso04_all\", \"Muon Pf Rel Iso 04 (All); Muon Pf Rel Iso 04 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso04_all\")\n",
    "#         hist['Data'][\"invariant_masses\"] = rdfOtherMuons['Data'].Histo1D((\"invariant_masses\", \"Invariant Masses for Two Muons (Oppositely Charged); Invariant Masses; Events\", 50, .5, 12), \"InvariantMasses\")        \n",
    "#         hist['Data'][\"invariant_masses_zoomed\"] = rdfOtherMuons['Data'].Histo1D((\"invariant_masses_zoomed\", \"Invariant Masses for Two Muons (Oppositely Charged); Invariant Masses; Events\", 50, 2.8, 3.4), \"InvariantMasses\")\n",
    "#         hist['Data'][\"jpsi_muons_pt\"] = rdfOtherMuons['Data'].Histo1D((\"Pt for JPsi Muons\", \"Transverse Momentum for JPsi Muons; Pt; Events\", 150, 2.8, 75), \"JPsiMuons_pt\")\n",
    "#         hist['Data'][\"jpsi_muons_eta\"] = rdfOtherMuons['Data'].Histo1D((\"Eta for JPsi Muons\", \"Pseudorapidity for JPsi Muons; Eta; Events\", 50, -3, 3), \"JPsiMuons_eta\")\n",
    "#         hist['Data'][\"jpsi_muons_phi\"] = rdfOtherMuons['Data'].Histo1D((\"Phi for JPsi Muons\", \"Angle for JPsi Muons; Phi; Events\", 50, -3.5, 3.5), \"JPsiMuons_phi\")\n",
    "#         hist['Data'][\"jpsi_muons_multiplicity\"] = rdfOtherMuons['Data'].Histo1D((\"jpsi_muon_multiplicity\", \"Number of J/Psi Muons; Number of J/Psi Muons; Events\", 8, 0, 8), \"JPsiMuons_multiplicity\")\n",
    "#         hist['Data'][\"delta_eta\"] = rdfOtherMuons['Data'].Histo1D((\"Delta Eta for Isolated Muon - JPsi Muons\", \"Delta Eta for Isolated Muon - JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEta\")\n",
    "#         hist['Data'][\"delta_phi\"] = rdfOtherMuons['Data'].Histo1D((\"Delta Phi for Isolated Muon - JPsi Muons\", \"Delta Phi for Isolated Muon - JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhi\")\n",
    "#         hist['Data'][\"delta_r\"] = rdfOtherMuons['Data'].Histo1D((\"Delta R for Isolated and JPsi Muons\", \"Delta R for Isolated and JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaR\")\n",
    "#         hist['Data'][\"invariant_masses_all_muons\"] = rdfOtherMuons['Data'].Histo1D((\"invariant_masses_all_muons\", \"Invariant Masses for Three Muons (Isolated and Paired, Oppositely Charged); Invariant Masses; Events\", 50, .5, 200), \"InvariantMassesAllMuons\")\n",
    "\n",
    "#     else:\n",
    "        \n",
    "#         hist[sample][\"isolated_mu_pt\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"mu_pt\",\"Monte Carlo \" + sample + \";Pt (GeV);Events\",100,20,220),\"IsolatedMuon_pt\",\"LumiXS\")\n",
    "#         hist[sample][\"isolated_mu_eta\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"mu_eta\", \"Monte Carlo \" + sample + \"; Eta; Events\",100,-3,3),\"IsolatedMuon_eta\",\"LumiXS\")\n",
    "#         hist[sample][\"isolated_mu_phi\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"mu_phi\", \"Monte Carlo \" + sample + \"; Phi (Radians); Events\",100,-3.5,3.5),\"IsolatedMuon_phi\",\"LumiXS\")\n",
    "#         hist[sample][\"jet1_pt\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet1_pt\", \"Monte Carlo \" + sample + \"; Pt (GeV); Events\", 100, 20, 200), \"SJet1_pt\", \"LumiXS\")\n",
    "#         hist[sample][\"jet2_pt\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet2_pt\", \"Monte Carlo \" + sample + \"; Pt (GeV); Events\", 100, 20, 200), \"SJet2_pt\", \"LumiXS\")\n",
    "#         hist[sample][\"jet1_eta\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet1_eta\", \"Monte Carlo \" + sample + \"; Eta; Events\", 100, -3, 3), \"SJet1_eta\", \"LumiXS\")\n",
    "#         hist[sample][\"jet2_eta\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet2_eta\", \"Monte Carlo \" + sample +\"; Eta; Events\", 100, -3, 3), \"SJet2_eta\", \"LumiXS\")\n",
    "#         hist[sample][\"jet1_phi\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet1_phi\", \"Monte Carlo \" + sample + \"; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet1_phi\", \"LumiXS\")\n",
    "#         hist[sample][\"jet2_phi\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet2_phi\", \"Monte Carlo \" + sample +\"; Phi (Radians); Events\", 100, -3.5, 3.5), \"SJet2_phi\", \"LumiXS\")\n",
    "#         hist[sample][\"jet_deep\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"jet_deep\", \"Monte Carlo \" + sample +\"; Discriminant Value; Events\", 100, 0, 1), \"DeepJetB\", \"LumiXS\")\n",
    "#         hist[sample][\"number_of_jets\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"number_of_jets\", \"Monte Carlo \" + sample +\"; Number Of Jets; Events\", 20, 0, 20), \"Num_Jets\", \"LumiXS\") \n",
    "#         hist[sample][\"number_of_muons\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"number_of_muons\", \"Monte Carlo \" + sample +\"; Number of Muons; Events\", 5, 0, 5), \"Num_Muons\", \"LumiXS\")\n",
    "#         hist[sample][\"transverse_mass\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"transverse_mass\", \"Monte Carlo \" + sample +\"; Transverse Mass (GeV); Events\", 150, 0, 150), \"MTofMETandMu\", \"LumiXS\")\n",
    "#         hist[sample][\"missing_transverse_momentum\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"missing_transverse_momentum\", \"Monte Carlo\" + sample + \"; Missing Transverse Momentum(GeV); Events\", 150, 0, 300), \"MET_pt\", \"LumiXS\")\n",
    "#         hist[sample][\"ht\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"ht\", \"Monte Carlo \" + sample + \"; Ht; Events\", 300, 0, 1500), \"Ht\", \"LumiXS\")\n",
    "#         hist[sample][\"isolated_muon_pfRelIso03_all\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"muon_pfRelIso03_all\", \"Monte Carlo \" + sample + \"; Muon Pf Rel Iso 03 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_all\", \"LumiXS\")\n",
    "#         hist[sample][\"isolated_muon_pfRelIso03_chg\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"muon_pfRelIso03_chg\", \"Monte Carlo \" + sample + \"; Muon Pf Rel Iso 03 (Chg); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso03_chg\", \"LumiXS\")\n",
    "#         hist[sample][\"isolated_muon_pfRelIso04_all\"] = rdfmu[sample].Histo1D((sample + \"_\" + \"muon_pfRelIso04_all\", \"Monte Carlo \" + sample + \"; Muon Pf Rel Iso 04 (All); Events\", 60, 0, .3), \"IsolatedMuon_pfRelIso04_all\", \"LumiXS\")\n",
    "#         hist[sample][\"invariant_masses\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"invariant_masses\", \"Monte Carlo \" + sample + \"; Invariant Masses for Two Muons (Oppositely Charged); Invariant Masses; Events\", 50, .5, 12), \"InvariantMasses\", \"LumiXS\")\n",
    "#         hist[sample][\"invariant_masses_zoomed\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"invariant_masses_zoomed\", \"Monte Carlo \" + sample + \"; Invariant Masses for Two Muons (Oppositely Charged); Events\", 50, 2.8, 3.4), \"InvariantMasses\", \"LumiXS\")\n",
    "#         hist[sample][\"jpsi_muons_pt\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_pt\", \"Monte Carlo \" + sample + \"; Transverse Momentum for JPsi Muons; Pt; Events\", 150, 2.8, 75), \"JPsiMuons_pt\", \"LumiXS\")\n",
    "#         hist[sample][\"jpsi_muons_eta\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_eta\", \"Monte Carlo \" + sample + \"; Pseudorapidity for JPsi Muons; Eta; Events\", 50, -3, 3), \"JPsiMuons_eta\", \"LumiXS\")\n",
    "#         hist[sample][\"jpsi_muons_phi\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_phi\", \"Monte Carlo \" + sample + \"; Angle for JPsi Muons; Phi; Events\", 50, -3.5, 3.5), \"JPsiMuons_phi\", \"LumiXS\")\n",
    "#         hist[sample][\"jpsi_muons_multiplicity\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muon_multiplicity\", \"Monte Carlo\" + sample + \"; Number of J/Psi Muons; Number of J/Psi Muons; Events\", 8, 0, 8), \"JPsiMuons_multiplicity\", \"LumiXS\")\n",
    "#         hist[sample][\"delta_eta\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"delta_eta\", \"Monte Carlo \" + sample + \"; Delta Eta for Isolated Muon - JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEta\", \"LumiXS\")\n",
    "#         hist[sample][\"delta_phi\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"delta_phi\", \"Monte Carlo \" + sample + \"; Delta Phi for Isolated Muon - JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhi\", \"LumiXS\")\n",
    "#         hist[sample][\"delta_r\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"delta_r\", \"Monte Carlo \" + sample + \"; Delta R for Isolated and JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaR\", \"LumiXS\")\n",
    "#         hist[sample][\"invariant_masses_all_muons\"] = rdfOtherMuons[sample].Histo1D((sample + \"_\" + \"invariant_masses_all_muons\", \"Monte Carlo\" + sample + \"; Invariant Masses for Three Muons (Isolated and Paired, Oppositely Charged); Invariant Masses; Events\", 50, .5, 200), \"InvariantMassesAllMuons\", \"LumiXS\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "prospective-permission",
   "metadata": {},
   "outputs": [],
   "source": [
    "for sample in dictOfListOfFiles:\n",
    "\n",
    "    ROOT.RDF.SaveGraph(rdf[sample], str(sample) + \".dot\")\n",
    "    os.system(\"dot -Tpdf \" + str(sample) + \".dot > \" + str(sample) + \"_graph.pdf\" )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "small-volleyball",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0xb6d4640>\n",
      "Name: 2018___Mu___Data___leading_muon_pt___nominal Title: Leading Muon Transverse Momentum NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ee11dd0>\n",
      "Name: 2018___Mu___Data___leading_muon_eta___nominal Title: Leading Muon Pseudorapidity NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ee1d150>\n",
      "Name: 2018___Mu___Data___leading_muon_phi___nominal Title: Leading Muon Angle NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ee0b8d0>\n",
      "Name: 2018___Mu___Data___leading_muon_mass___nominal Title: Leading Muon Mass NbinsX: 10\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ee33900>\n",
      "Name: 2018___Mu___Data___leading_muon_charge___nominal Title: Leading Muon Charge NbinsX: 5\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ef6cf20>\n",
      "Name: 2018___Mu___MonteCarloTTToSemiLeptonic___leading_muon_pt___nominal Title: Monte Carlo MonteCarloTTToSemiLeptonic NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f09d2d0>\n",
      "Name: 2018___Mu___MonteCarloTTToSemiLeptonic___leading_muon_eta___nominal Title: Monte Carlo MonteCarloTTToSemiLeptonic NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ef82f20>\n",
      "Name: 2018___Mu___MonteCarloTTToSemiLeptonic___leading_muon_phi___nominal Title: Monte Carlo MonteCarloTTToSemiLeptonic NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f143a10>\n",
      "Name: 2018___Mu___MonteCarloTTToSemiLeptonic___leading_muon_mass___nominal Title: Monte Carlo MonteCarloTTToSemiLeptonic NbinsX: 10\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f13e820>\n",
      "Name: 2018___Mu___MonteCarloTTToSemiLeptonic___leading_muon_charge___nominal Title: Monte Carlo MonteCarloTTToSemiLeptonic NbinsX: 5\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f14df90>\n",
      "Name: 2018___Mu___MonteCarloTTTo2L2Nu___leading_muon_pt___nominal Title: Monte Carlo MonteCarloTTTo2L2Nu NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f10c9a0>\n",
      "Name: 2018___Mu___MonteCarloTTTo2L2Nu___leading_muon_eta___nominal Title: Monte Carlo MonteCarloTTTo2L2Nu NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f0d4e30>\n",
      "Name: 2018___Mu___MonteCarloTTTo2L2Nu___leading_muon_phi___nominal Title: Monte Carlo MonteCarloTTTo2L2Nu NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f17f9c0>\n",
      "Name: 2018___Mu___MonteCarloTTTo2L2Nu___leading_muon_mass___nominal Title: Monte Carlo MonteCarloTTTo2L2Nu NbinsX: 10\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f0807d0>\n",
      "Name: 2018___Mu___MonteCarloTTTo2L2Nu___leading_muon_charge___nominal Title: Monte Carlo MonteCarloTTTo2L2Nu NbinsX: 5\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f191ea0>\n",
      "Name: 2018___Mu___MonteCarloWJetsToLNu___leading_muon_pt___nominal Title: Monte Carlo MonteCarloWJetsToLNu NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f0eaf40>\n",
      "Name: 2018___Mu___MonteCarloWJetsToLNu___leading_muon_eta___nominal Title: Monte Carlo MonteCarloWJetsToLNu NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ef82c10>\n",
      "Name: 2018___Mu___MonteCarloWJetsToLNu___leading_muon_phi___nominal Title: Monte Carlo MonteCarloWJetsToLNu NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f16e990>\n",
      "Name: 2018___Mu___MonteCarloWJetsToLNu___leading_muon_mass___nominal Title: Monte Carlo MonteCarloWJetsToLNu NbinsX: 10\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f145050>\n",
      "Name: 2018___Mu___MonteCarloWJetsToLNu___leading_muon_charge___nominal Title: Monte Carlo MonteCarloWJetsToLNu NbinsX: 5\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ef811a0>\n",
      "Name: 2018___Mu___MonteCarloST_tW_top___leading_muon_pt___nominal Title: Monte Carlo MonteCarloST_tW_top NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f0871c0>\n",
      "Name: 2018___Mu___MonteCarloST_tW_top___leading_muon_eta___nominal Title: Monte Carlo MonteCarloST_tW_top NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ef80f00>\n",
      "Name: 2018___Mu___MonteCarloST_tW_top___leading_muon_phi___nominal Title: Monte Carlo MonteCarloST_tW_top NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f09ad20>\n",
      "Name: 2018___Mu___MonteCarloST_tW_top___leading_muon_mass___nominal Title: Monte Carlo MonteCarloST_tW_top NbinsX: 10\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f1203d0>\n",
      "Name: 2018___Mu___MonteCarloST_tW_top___leading_muon_charge___nominal Title: Monte Carlo MonteCarloST_tW_top NbinsX: 5\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f1216a0>\n",
      "Name: 2018___Mu___MonteCarloST_tchannel_top___leading_muon_pt___nominal Title: Monte Carlo MonteCarloST_tchannel_top NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f07ca00>\n",
      "Name: 2018___Mu___MonteCarloST_tchannel_top___leading_muon_eta___nominal Title: Monte Carlo MonteCarloST_tchannel_top NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ef817c0>\n",
      "Name: 2018___Mu___MonteCarloST_tchannel_top___leading_muon_phi___nominal Title: Monte Carlo MonteCarloST_tchannel_top NbinsX: 100\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3ef81880>\n",
      "Name: 2018___Mu___MonteCarloST_tchannel_top___leading_muon_mass___nominal Title: Monte Carlo MonteCarloST_tchannel_top NbinsX: 10\n",
      "<cppyy.gbl.ROOT.RDF.RResultPtr<TH1D> object at 0x3f083330>\n",
      "Name: 2018___Mu___MonteCarloST_tchannel_top___leading_muon_charge___nominal Title: Monte Carlo MonteCarloST_tchannel_top NbinsX: 5\n",
      "HLTTriggerSingleMuonTrigger: pass=2906161    all=2906161    -- eff=100.00 % cumulative eff=100.00 %\n",
      "HLTTriggerSingleMuonTrigger: pass=660353     all=660353     -- eff=100.00 % cumulative eff=100.00 %\n",
      "No Abnormal Weights: pass=660353     all=660353     -- eff=100.00 % cumulative eff=100.00 %\n",
      "HLTTriggerSingleMuonTrigger: pass=702213     all=702213     -- eff=100.00 % cumulative eff=100.00 %\n",
      "No Abnormal Weights: pass=702213     all=702213     -- eff=100.00 % cumulative eff=100.00 %\n",
      "HLTTriggerSingleMuonTrigger: pass=22028      all=22028      -- eff=100.00 % cumulative eff=100.00 %\n",
      "No Abnormal Weights: pass=22027      all=22028      -- eff=100.00 % cumulative eff=100.00 %\n",
      "HLTTriggerSingleMuonTrigger: pass=306        all=306        -- eff=100.00 % cumulative eff=100.00 %\n",
      "No Abnormal Weights: pass=306        all=306        -- eff=100.00 % cumulative eff=100.00 %\n",
      "HLTTriggerSingleMuonTrigger: pass=2748       all=2748       -- eff=100.00 % cumulative eff=100.00 %\n",
      "No Abnormal Weights: pass=2748       all=2748       -- eff=100.00 % cumulative eff=100.00 %\n"
     ]
    }
   ],
   "source": [
    "for sample in dictOfListOfFiles:\n",
    "    #nparray[sample] = nparraynode[sample].AsNumpy([\"genWeight\", \"event\", \"run\"])\n",
    "    \n",
    "    cutflow = report[sample].GetValue()\n",
    "    cutflow.Print()\n",
    "    \n",
    "    era = \"2018\"\n",
    "    process = sample\n",
    "    channel = \"Mu\"\n",
    "    syst = \"nominal\"\n",
    "\n",
    "    outFile = ROOT.TFile.Open(\"{}_{}_{}.root\".format(era, channel, process), \"RECREATE\")\n",
    "    for name, hist_pointer in hist[sample].items():\n",
    "        print(hist_pointer)\n",
    "        hist_value = hist_pointer.GetValue()\n",
    "        \n",
    "        hist_value.SetName(\"{}___{}___{}___{}___{}\".format(era, channel, process, name, syst))\n",
    "        print(hist_value)\n",
    "        hist_value.Write()\n",
    "\n",
    "    outFile.Close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "58cd86df",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1.2101066e+05 9.8388500e+00 9.8388500e+00 ... 9.6518002e+00 9.6518002e+00\n",
      " 9.6517296e+00]\n"
     ]
    }
   ],
   "source": [
    "#print(nparray['MonteCarloWJetsToLNu'].keys())\n",
    "\n",
    "#a = np.sort(nparray['MonteCarloWJetsToLNu']['genWeight'])\n",
    "\n",
    "#print(a[:10:-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16ec3f98",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  },
  "sparkconnect": {
   "bundled_options": [],
   "list_of_options": []
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
