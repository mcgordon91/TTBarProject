{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "hawaiian-importance",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Welcome to JupyROOT 6.26/04\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Warning in <RTaskArenaWrapper>: CPU Bandwith Control Active. Proceeding with 4 threads accordingly\n"
     ]
    }
   ],
   "source": [
    "import ROOT\n",
    "import glob\n",
    "import numpy as np\n",
    "import os\n",
    "ROOT.gROOT.ProcessLine(\".L FTFunctions.cpp\")\n",
    "ROOT.gInterpreter.Declare(\"\"\"\n",
    "    const UInt_t barWidth = 60;\n",
    "    ULong64_t processed = 0, totalEvents = 0;\n",
    "    std::string progressBar;\n",
    "    std::mutex barMutex; \n",
    "    auto registerEvents = [](ULong64_t nIncrement) {totalEvents += nIncrement;};\n",
    "    ROOT::RDF::RResultPtr<ULong64_t> AddProgressBar(ROOT::RDF::RNode df, int everyN=10000, int totalN=100000) {\n",
    "        registerEvents(totalN);\n",
    "        auto c = df.Count();\n",
    "        c.OnPartialResultSlot(everyN, [everyN] (unsigned int slot, ULong64_t &cnt){\n",
    "            std::lock_guard<std::mutex> l(barMutex);\n",
    "            processed += everyN; //everyN captured by value for this lambda\n",
    "            progressBar = \"[\";\n",
    "            for(UInt_t i = 0; i < static_cast<UInt_t>(static_cast<Float_t>(processed)/totalEvents*barWidth); ++i){\n",
    "                progressBar.push_back('|');\n",
    "            }\n",
    "            // escape the '\\' when defined in python string\n",
    "            std::cout << \"\\\\r\" << std::left << std::setw(barWidth) << progressBar << \"] \" << processed << \"/\" << totalEvents << std::flush;\n",
    "        });\n",
    "        return c;\n",
    "    }\n",
    "\"\"\")\n",
    "# Enables multithreading\n",
    "useRange = False\n",
    "if not useRange:\n",
    "    nThreads = 8\n",
    "    ROOT.ROOT.EnableImplicitMT(nThreads)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "nominated-resource",
   "metadata": {},
   "outputs": [],
   "source": [
    "listOfFilesData = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/SingleMuon/*/*.root\")\n",
    "listOfFilesMonteCarloTTToSemiLeptonic = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloTTTo2L2Nu = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTTo2L2Nu_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloWJetsToLNu = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/WJetsToLNu_TuneCP5_13TeV-madgraphMLM-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloST_tW_top = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/ST_tW_top_5f_inclusiveDecays_TuneCP5_13TeV-powheg-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloST_tchannel_top = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/ST_t-channel_top_4f_InclusiveDecays_TuneCP5_13TeV-powheg-madspin-pythia8/*/*.root\")\n",
    "listOfFilesMonteCarloMT166 = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_mtop166p5_TuneCP5_13TeV-powheg-pythia8/*/*/*.root\")\n",
    "listOfFilesMonteCarloMT169 = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_mtop169p5_TuneCP5_13TeV-powheg-pythia8/*/*/*.root\")\n",
    "listOfFilesMonteCarloMT171 = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_mtop171p5_TuneCP5_13TeV-powheg-pythia8/*/*/*.root\")\n",
    "listOfFilesMonteCarloMT173 = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_mtop173p5_TuneCP5_13TeV-powheg-pythia8/*/*/*.root\")\n",
    "listOfFilesMonteCarloMT175 = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_mtop175p5_TuneCP5_13TeV-powheg-pythia8/*/*/*.root\")\n",
    "listOfFilesMonteCarloMT178 = glob.glob(\"/eos/user/m/migordon/SWAN_projects/JPsiSkims/TTToSemiLeptonic_mtop178p5_TuneCP5_13TeV-powheg-pythia8/*/*/*.root\")\n",
    "\n",
    "dictOfListOfFiles = {\"gen_data\" : listOfFilesData, \"TTToSemileptonic\" : listOfFilesMonteCarloTTToSemiLeptonic, \"TTTo2L2Nu\" : listOfFilesMonteCarloTTTo2L2Nu, \"WJetsToLNu\" : listOfFilesMonteCarloWJetsToLNu, \"ST_tW_top\" : listOfFilesMonteCarloST_tW_top, \"ST_tchannel_top\" : listOfFilesMonteCarloST_tchannel_top,\\\n",
    "                     \"MT166\" : listOfFilesMonteCarloMT166, \"MT169\" : listOfFilesMonteCarloMT169, \"MT171\" : listOfFilesMonteCarloMT171, \"MT173\" : listOfFilesMonteCarloMT173, \"MT175\" : listOfFilesMonteCarloMT175, \"MT178\": listOfFilesMonteCarloMT178} "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "international-panic",
   "metadata": {},
   "outputs": [],
   "source": [
    "chain = {}\n",
    "meta = {}\n",
    "rdf = {}\n",
    "mrdf = {}\n",
    "nevents = {}\n",
    "sumweight = {}\n",
    "neventsVal = {}\n",
    "\n",
    "mureport = {}\n",
    "\n",
    "rdfPassedIsolatedLeptonTrigger = {}\n",
    "rdfIsolatedLeptonNoHighWeights = {}\n",
    "rdfIsolatedMuonNoHighWeights = {}\n",
    "rdfIsolatedElectronNoHighWeights = {}\n",
    "rdfIsolatedMuonAfterMETCut = {}\n",
    "rdfIsolatedElectronAfterMETCut = {}\n",
    "\n",
    "rdfJetAndIsolatedLeptonFiltered = {}\n",
    "\n",
    "rdfJPsiMuons = {}\n",
    "\n",
    "rdfJPsiMuonsOppositelyCharged = {}\n",
    "\n",
    "rdfJPsisInPeak = {}\n",
    "\n",
    "rdfMCTruth = {}\n",
    "\n",
    "hist = {}\n",
    "report = {}\n",
    "\n",
    "\n",
    "nparray = {}\n",
    "nparraynode = {}\n",
    "\n",
    "# Muon_pfIsoId is PFIso ID from miniAOD selector (1=PFIsoVeryLoose, 2=PFIsoLoose, 3=PFIsoMedium, 4=PFIsoTight, 5=PFIsoVeryTight, 6=PFIsoVeryVeryTight)\n",
    "LeadingIsolatedMuonMask = \"Muon_pt > 30 && abs(Muon_eta) < 2.4 && Muon_mediumId == true && Muon_pfIsoId >= 4\"\n",
    "LeadingIsolatedElectronMask = \"Electron_pt > 30 && abs(Electron_eta) < 2.4 && Electron_cutBased == 4\"\n",
    "JetMask = \"ROOT::VecOps::RVec<Int_t> jmask = (Jet_pt >= 30 && abs(Jet_eta) <= 2.5 && Jet_jetId >= 2); \"\\\n",
    "                          \"for(int i=0; i < LeadingIsolatedMuon_pt.size(); ++i){\"\\\n",
    "                              \"ROOT::VecOps::RVec<Float_t> dr;\"\\\n",
    "                              \"for(int j=0; j < jmask.size(); ++j){\"\\\n",
    "                                  \"dr.push_back(ROOT::VecOps::DeltaR(Jet_eta.at(j), LeadingIsolatedMuon_eta.at(i), Jet_phi.at(j), LeadingIsolatedMuon_phi.at(i)));}\"\\\n",
    "                                  \"jmask = jmask && dr >= 0.4;\"\\\n",
    "                                  \"dr.clear();}\"\\\n",
    "                          \"return jmask;\"\n",
    "JPsiMuonCandidateMask = \"Muon_pt > 6 && abs(Muon_eta) <= 2.4 && Muon_mediumId == true && !(leading_isolated_muon_mask)\"\n",
    "JPsiMuonCorrectIMDR = \"MuonCorrectIMDR == 1\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "f2470268",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<cppyy.gbl.ROOT.RDF.RResultPtr<ROOT::RDF::RCutFlowReport> object at 0xc697120>\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Warning in <TClass::Init>: no dictionary for class edm::Hash<1> is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ProcessHistory is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ProcessConfiguration is available\n",
      "Warning in <TClass::Init>: no dictionary for class edm::ParameterSetBlob is available\n",
      "Warning in <TClass::Init>: no dictionary for class pair<edm::Hash<1>,edm::ParameterSetBlob> is available\n"
     ]
    }
   ],
   "source": [
    "for sample, fileList in dictOfListOfFiles.items():\n",
    "\n",
    "    if sample == 'gen_data':\n",
    "        vecList = ROOT.std.vector(str)()\n",
    "\n",
    "        for element in dictOfListOfFiles['gen_data']:\n",
    "            vecList.push_back(element)\n",
    "\n",
    "        rdf['gen_data'] = ROOT.ROOT.RDataFrame(\"Events\", vecList)    \n",
    "        mureport['gen_data'] = rdf['gen_data'].Report()\n",
    "        \n",
    "        print(rdf['gen_data'].Report())\n",
    "        mrdf['gen_data'] = ROOT.ROOT.RDataFrame(\"Runs\", vecList)\n",
    "        \n",
    "        if useRange:\n",
    "            rdf['gen_data'] = rdf['gen_data'].Range(5000)\n",
    "            nrange = 5000\n",
    "            printcode = ' if(rdfentry_ % 5000 == 0) { std::cout << \"Processed entry \" << rdfentry_ << \"/' + str(nrange) + '\" << std::endl; } return rdfentry_;'\n",
    "            print(\"Data run\")\n",
    "            rdf['gen_data'] = rdf['gen_data'].Define(\"my_rdfentry\", printcode)\n",
    "            \n",
    "\n",
    "        \n",
    "    else:\n",
    "        chain[sample] = ROOT.TChain(\"Events\")\n",
    "        meta[sample] = ROOT.TChain(\"Runs\")\n",
    "\n",
    "        for file in fileList:\n",
    "            \n",
    "            chain[sample].Add(file)\n",
    "            meta[sample].Add(file)\n",
    "\n",
    "        rdf[sample] = ROOT.ROOT.RDataFrame(chain[sample])\n",
    "        mureport[sample] = rdf[sample].Report()\n",
    "        mrdf[sample] = ROOT.ROOT.RDataFrame(meta[sample])\n",
    "        \n",
    "        if useRange:\n",
    "            rdf[sample] = rdf[sample].Range(5000)\n",
    "            \n",
    "            printcode = ' if(rdfentry_ % 5000 == 0) { std::cout << \"Processed entry \" << rdfentry_ << \" \" << rdfslot_ << std::endl; } return rdfentry_;'\n",
    "            print(\"MC run\")\n",
    "            rdf[sample] = rdf[sample].Define(\"my_rdfentry\", printcode)\n",
    "\n",
    "        nevents[sample] = mrdf[sample].Sum(\"genEventCount\")\n",
    "        sumweight[sample] = mrdf[sample].Sum(\"genEventSumw\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "paperback-video",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Semileptonic ttbar xsection: 364.3109\n",
    "#Single mu trigger for 2017 (B,C,D,E,F): \"HLT_IsoMu27\"\n",
    "#\"HLT_Ele35_WPTight_Gsf\"\n",
    "#lumiDict = {\"2017\": 41.53, \"2018\": 59.97}\n",
    "wgtFormula = {}\n",
    "\n",
    "# wgtFormula used to weight each event\n",
    "# XS = Literature Cross section of the process of interest (in picobarnes; the 1000 converts to femotobarnes), lumi = presumed luminosity of the data one is normalizing against; XS * lumi = # of expected events;\n",
    "# genWeight = quantity stored in every event which comes from the Monte Carlo generator telling you what the value of the generated event is (usually close to 1); it can be + or -; it also contains matching\n",
    "#     effeciency; tells you the Monte Carlo defined value of the event\n",
    "# sW = sum of weights; normalizes the genWeight\n",
    "lumiDict = {\"2018\": 59.97} #  brilcalc lumi --normtag /cvmfs/cms-bril.cern.ch/cms-lumi-pog/Normtags/normtag_PHYSICS.json -u /fb --begin 302031 --end 302663 --hltpath \"HLT_IsoMu27*\"\n",
    "wgtFormula['gen_data'] = \"1\"\n",
    "wgtFormula['TTToSemileptonic'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=364.31, lumi=lumiDict[\"2018\"], sW=float(sumweight['TTToSemileptonic'].GetValue()))\n",
    "wgtFormula['TTTo2L2Nu'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=87.33, lumi=lumiDict[\"2018\"], sW=float(sumweight['TTTo2L2Nu'].GetValue()))\n",
    "wgtFormula['WJetsToLNu'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=61526.7, lumi=lumiDict[\"2018\"], sW=float(sumweight['WJetsToLNu'].GetValue()))\n",
    "wgtFormula['ST_tW_top'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=71.7, lumi=lumiDict[\"2018\"], sW=float(sumweight['ST_tW_top'].GetValue()))\n",
    "wgtFormula['ST_tchannel_top'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=130, lumi=lumiDict[\"2018\"], sW=float(sumweight['ST_tchannel_top'].GetValue()))\n",
    "wgtFormula['MT166'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=811.4, lumi=lumiDict[\"2018\"], sW=float(sumweight['MT166'].GetValue()))\n",
    "wgtFormula['MT169'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=746.2, lumi=lumiDict[\"2018\"], sW=float(sumweight['MT169'].GetValue()))\n",
    "wgtFormula['MT171'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=706.1, lumi=lumiDict[\"2018\"], sW=float(sumweight['MT171'].GetValue()))\n",
    "wgtFormula['MT173'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=668.6, lumi=lumiDict[\"2018\"], sW=float(sumweight['MT173'].GetValue()))\n",
    "wgtFormula['MT175'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=633.4, lumi=lumiDict[\"2018\"], sW=float(sumweight['MT175'].GetValue()))\n",
    "wgtFormula['MT178'] = \"{XS:f} * {lumi:f} * 1000 * genWeight / {sW:f}\".format(XS=584.6, lumi=lumiDict[\"2018\"], sW=float(sumweight['MT178'].GetValue()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "better-deputy",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cpp_code_1 = \"\"\"\n",
    "typedef ROOT::VecOps::RVec<Float_t>                        RVec_f;\n",
    "typedef ROOT::VecOps::RVec<Int_t>                          RVec_i;\n",
    "typedef ROOT::VecOps::RVec<Long_t>                         RVec_l;\n",
    "typedef ROOT::VecOps::RVec<std::tuple<Float_t, Float_t>>   RVec_ff;\n",
    "\n",
    "typedef ROOT::VecOps::RVec<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double>>> RVec_FourVector;\n",
    "const float dr_cut = 0;\n",
    "const float low_jpsi_im_cut = 3.0;\n",
    "const float high_jpsi_im_cut = 3.2;\n",
    "const float three_body_im_cut = 20;\n",
    "\n",
    "\n",
    "class MuonAndJPsiStatisticsAndKinematics\n",
    "{\n",
    "    private:\n",
    "        RVec_f JPsi_Muon_pt;\n",
    "        RVec_f JPsi_Muon_eta;\n",
    "        RVec_f JPsi_Muon_phi;\n",
    "        RVec_f JPsi_Muon_mass;\n",
    "        RVec_i JPsi_Muon_charge;\n",
    "        RVec_f Isolated_Muon_pt;\n",
    "        RVec_f Isolated_Muon_eta;\n",
    "        RVec_f Isolated_Muon_phi;\n",
    "        RVec_f Isolated_Muon_mass;\n",
    "        RVec_i Isolated_Muon_charge;\n",
    "        RVec_f Isolated_Muon_PfRelIso03_all;\n",
    "        RVec_f JPsi_Muon_PfRelIso03_all;\n",
    "\n",
    "\n",
    "    public:\n",
    "        MuonAndJPsiStatisticsAndKinematics(RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge);\n",
    "        MuonAndJPsiStatisticsAndKinematics(RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge);\n",
    "        MuonAndJPsiStatisticsAndKinematics(RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f Isolated_Muon_PfRelIso03_all, RVec_f JPsi_Muon_PfRelIso03_all);\n",
    "        \n",
    "        RVec_i IsOppositeChargeCorrectIM();\n",
    "        \n",
    "        RVec_FourVector JPsiFourVectorCalculator();\n",
    "        RVec_FourVector JPsiForMuonsInPeakFourVectorCalculator();\n",
    "        RVec_FourVector ThreeBodyInPeakFourVectorCalculator();\n",
    "        \n",
    "        RVec_i ReturnNumJPsis();\n",
    "        \n",
    "        RVec_f ReturnJPsiPt();\n",
    "        RVec_f ReturnJPsiEta();\n",
    "        RVec_f ReturnJPsiPhi();\n",
    "        \n",
    "        RVec_f JPsiMuonInvariantMassCalculator();\n",
    "        RVec_f IsolatedAndJPsiMuonInvariantMassCalculator();\n",
    "        \n",
    "        RVec_f ReturnMuonPfRelIso03AllForIsolatedMuonInInvariantMass();\n",
    "        RVec_f ReturnMuonPfRelIso03AllForJPsiMuonsInInvariantMass();\n",
    "        RVec_f ReturnJPsiMassforJPsiInInvariantMass();\n",
    "        \n",
    "        RVec_f DeltaEtaBetweenIsolatedAndJPsiMuonCalculator();\n",
    "        RVec_f DeltaPhiBetweenIsolatedAndJPsiMuonCalculator();\n",
    "        RVec_f DeltaRBetweenIsolatedAndJPsiMuonCalculator();\n",
    "        \n",
    "        RVec_f DeltaEtaBetweenJPsiMuonsCalculator();\n",
    "        RVec_f DeltaPhiBetweenJPsiMuonsCalculator();\n",
    "        RVec_f DeltaRBetweenJPsiMuonsCalculator();\n",
    "        \n",
    "        RVec_f ReturnDeltaEtaBetweenJPsiMuonsInPeak();\n",
    "        RVec_f ReturnDeltaPhiBetweenJPsiMuonsInPeak();\n",
    "        RVec_f ReturnDeltaRBetweenJPsiMuonsInPeak();\n",
    "        \n",
    "        RVec_f DeltaEtaBetweenIsolatedMuonAndJPsiCalculator();\n",
    "        RVec_f DeltaPhiBetweenIsolatedMuonAndJPsiCalculator();\n",
    "        RVec_f DeltaRBetweenIsolatedMuonAndJPsiCalculator();\n",
    "        \n",
    "        RVec_f ReturnLowDeltaRIsolatedMuonAndJPsiMuonPt(bool);\n",
    "        RVec_f ReturnJPsiInPeakMass();\n",
    "        RVec_f ReturnJPsiMuonPtInPeak();\n",
    "        RVec_f ReturnJPsiMuonEtaInPeak();\n",
    "        RVec_f ReturnJPsiMuonPhiInPeak();\n",
    "        RVec_f ReturnJPsiMuonChargeInPeak();\n",
    "        RVec_f ReturnJPsiInPeakPt();\n",
    "        RVec_f ReturnJPsiMuonPtInPeak(bool);\n",
    "        RVec_f ReturnJPsiMuonInPeakPfRelIso03All();\n",
    "        RVec_f ReturnTopQuarkInPeakMass();\n",
    "        \n",
    "        RVec_f DeltaEtaBetweenIsolatedMuonAndJPsiInPeakCalculator();\n",
    "        RVec_f DeltaPhiBetweenIsolatedMuonAndJPsiInPeakCalculator();\n",
    "        RVec_f DeltaRBetweenIsolatedMuonAndJPsiInPeakCalculator();\n",
    "        \n",
    "        RVec_f IsolatedMuonAndJPsiInPeakCalculator();\n",
    "\n",
    "};\n",
    "\n",
    "MuonAndJPsiStatisticsAndKinematics::MuonAndJPsiStatisticsAndKinematics(RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge)\n",
    "{\n",
    "    this->JPsi_Muon_pt = JPsi_Muon_pt;\n",
    "    this->JPsi_Muon_eta = JPsi_Muon_eta;\n",
    "    this->JPsi_Muon_phi = JPsi_Muon_phi;\n",
    "    this->JPsi_Muon_mass = JPsi_Muon_mass;\n",
    "    this->JPsi_Muon_charge = JPsi_Muon_charge;\n",
    "    this->Isolated_Muon_pt = {};\n",
    "    this->Isolated_Muon_eta = {};\n",
    "    this->Isolated_Muon_phi = {};\n",
    "    this->Isolated_Muon_mass = {};\n",
    "    this->Isolated_Muon_charge = {};\n",
    "    this->Isolated_Muon_PfRelIso03_all = {};\n",
    "    this->JPsi_Muon_PfRelIso03_all = {};\n",
    "}\n",
    "\n",
    "MuonAndJPsiStatisticsAndKinematics::MuonAndJPsiStatisticsAndKinematics(RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge)\n",
    "{\n",
    "    this->JPsi_Muon_pt = JPsi_Muon_pt;\n",
    "    this->JPsi_Muon_eta = JPsi_Muon_eta;\n",
    "    this->JPsi_Muon_phi = JPsi_Muon_phi;\n",
    "    this->JPsi_Muon_mass = JPsi_Muon_mass;\n",
    "    this->JPsi_Muon_charge = JPsi_Muon_charge;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "    this->Isolated_Muon_PfRelIso03_all = {};\n",
    "    this->JPsi_Muon_PfRelIso03_all = {};\n",
    "}\n",
    "\n",
    "MuonAndJPsiStatisticsAndKinematics::MuonAndJPsiStatisticsAndKinematics(RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f Isolated_Muon_PfRelIso03_all, RVec_f JPsi_Muon_PfRelIso03_all)\n",
    "{\n",
    "    this->JPsi_Muon_pt = JPsi_Muon_pt;\n",
    "    this->JPsi_Muon_eta = JPsi_Muon_eta;\n",
    "    this->JPsi_Muon_phi = JPsi_Muon_phi;\n",
    "    this->JPsi_Muon_mass = JPsi_Muon_mass;\n",
    "    this->JPsi_Muon_charge = JPsi_Muon_charge;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "    this->Isolated_Muon_PfRelIso03_all = Isolated_Muon_PfRelIso03_all;\n",
    "    this->JPsi_Muon_PfRelIso03_all = JPsi_Muon_PfRelIso03_all;\n",
    "}\n",
    "\n",
    "RVec_i MuonAndJPsiStatisticsAndKinematics::IsOppositeChargeCorrectIM()\n",
    "{\n",
    "\n",
    "    RVec_i GoodMuonFlag = {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "\n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                \n",
    "                auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                \n",
    "                EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                EtaJPsi = JPsi.Eta();\n",
    "                PhiJPsi = JPsi.Phi();\n",
    "        \n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                \n",
    "                pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "                \n",
    "                im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                \n",
    "                if((FirstMuonCharge * SecondMuonCharge == -1) && (im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (dr > dr_cut) && (im_three > three_body_im_cut))\n",
    "                {\n",
    "                    GoodMuonFlag.push_back(1);\n",
    "                }\n",
    "                \n",
    "                else\n",
    "                {\n",
    "                    GoodMuonFlag.push_back(0);\n",
    "                }\n",
    "\n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return GoodMuonFlag;   \n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_FourVector MuonAndJPsiStatisticsAndKinematics::JPsiFourVectorCalculator()\n",
    "{\n",
    "\n",
    "    RVec_FourVector fvt = {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "    for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "    {    \n",
    "\n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "        \n",
    "        /* If charges are opposite, calculate the invariant mass of them */\n",
    "        for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {\n",
    "                auto FourVector1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                \n",
    "                auto FourVector2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                \n",
    "                fvt.push_back(FourVector1 + FourVector2);\n",
    "                    \n",
    "                FourVector1 = {};\n",
    "                FourVector2 = {};\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return fvt;   \n",
    "}\n",
    "\n",
    "RVec_FourVector MuonAndJPsiStatisticsAndKinematics::JPsiForMuonsInPeakFourVectorCalculator()\n",
    "{\n",
    "\n",
    "    RVec_FourVector fvt = {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                \n",
    "                auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                \n",
    "                EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                EtaJPsi = JPsi.Eta();\n",
    "                PhiJPsi = JPsi.Phi();\n",
    "        \n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                \n",
    "                pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "                \n",
    "                im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "\n",
    "                if((FirstMuonCharge * SecondMuonCharge == -1) && (im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (dr > dr_cut) && (im_three > three_body_im_cut))\n",
    "                {\n",
    "                    fvt.push_back(JPsi);\n",
    "                }\n",
    "\n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return fvt;   \n",
    "}\n",
    "\n",
    "RVec_FourVector MuonAndJPsiStatisticsAndKinematics::ThreeBodyInPeakFourVectorCalculator()\n",
    "{\n",
    "\n",
    "    RVec_FourVector fvt = {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "\n",
    "                if((FirstMuonCharge * SecondMuonCharge == -1) && (ROOT::VecOps::InvariantMass(pt, eta, phi, mass) > 3.0) && (ROOT::VecOps::InvariantMass(pt, eta, phi, mass) < 3.2))\n",
    "                {\n",
    "                    auto FourVector1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    auto FourVector2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    auto FourVector3 = ROOT::Math::PtEtaPhiMVector (this->Isolated_Muon_pt[k], this->Isolated_Muon_eta[k], this->Isolated_Muon_phi[k], this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                    fvt.push_back(FourVector1 + FourVector2 + FourVector3);\n",
    "\n",
    "                    FourVector1 = {};\n",
    "                    FourVector2 = {};\n",
    "                    FourVector3 = {};\n",
    "                }\n",
    "\n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return fvt;   \n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_i MuonAndJPsiStatisticsAndKinematics::ReturnNumJPsis()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiForMuonsInPeakFourVectorCalculator();\n",
    "    \n",
    "    RVec_i NumberOfJPsis = {};\n",
    "    \n",
    "    NumberOfJPsis.push_back(FourVectorTotal.size());\n",
    "    \n",
    "    return NumberOfJPsis;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiPt()\n",
    "{\n",
    "    RVec_f JPsiPt = {};\n",
    "    \n",
    "    RVec_FourVector FourVectorTotal = JPsiFourVectorCalculator();\n",
    "    \n",
    "    for(int i = 0; i < FourVectorTotal.size(); i++)\n",
    "    {\n",
    "        JPsiPt.push_back(FourVectorTotal.at(i).Pt());\n",
    "    }\n",
    "    \n",
    "    return JPsiPt;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiEta()\n",
    "{\n",
    "    RVec_f JPsiEta = {};\n",
    "    \n",
    "    RVec_FourVector FourVectorTotal = JPsiFourVectorCalculator();\n",
    "    \n",
    "    for(int i = 0; i < FourVectorTotal.size(); i++)\n",
    "    {\n",
    "        JPsiEta.push_back(FourVectorTotal.at(i).Eta());\n",
    "    }\n",
    "    \n",
    "    return JPsiEta;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiPhi()\n",
    "{\n",
    "    RVec_f JPsiPhi = {};\n",
    "    \n",
    "    RVec_FourVector FourVectorTotal = JPsiFourVectorCalculator();\n",
    "    \n",
    "    for(int i = 0; i < FourVectorTotal.size(); i++)\n",
    "    {\n",
    "        JPsiPhi.push_back(FourVectorTotal.at(i).Phi());\n",
    "    }\n",
    "    \n",
    "    return JPsiPhi;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "/* This function matches each muon with oppositely charged muons. */\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::JPsiMuonInvariantMassCalculator()\n",
    "{ \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f InvariantMasses {};\n",
    "    \n",
    "    float im = 0;\n",
    " \n",
    "    /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "    for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "    {    \n",
    "\n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "        \n",
    "        /* If charges are opposite, calculate the invariant mass of them */\n",
    "        for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "                    \n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                \n",
    "                InvariantMasses.push_back(im);\n",
    "                    \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return InvariantMasses;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::IsolatedAndJPsiMuonInvariantMassCalculator()\n",
    "{\n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f InvariantMasses {};\n",
    "    \n",
    "    float im = 0;\n",
    " \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "    \n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {\n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "\n",
    "                    InvariantMasses.push_back(im);\n",
    "\n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return InvariantMasses;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnMuonPfRelIso03AllForIsolatedMuonInInvariantMass()\n",
    "{\n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    RVec_f Isolations {};\n",
    "    \n",
    "    bool IsolatedMuonAlreadyAccountedFor = false;\n",
    " \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "    \n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {\n",
    "                \n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                    \n",
    "                    if((im >= 90) && (im <= 120))\n",
    "                    {\n",
    "                        if(!IsolatedMuonAlreadyAccountedFor)\n",
    "                        {\n",
    "                            Isolations.push_back(this->Isolated_Muon_PfRelIso03_all[k]);\n",
    "                            \n",
    "                            IsolatedMuonAlreadyAccountedFor = true;\n",
    "                        }\n",
    "                    }\n",
    "                    \n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "                   \n",
    "                }\n",
    "            }\n",
    "        }\n",
    "        \n",
    "        IsolatedMuonAlreadyAccountedFor = false;\n",
    "    }\n",
    "        \n",
    "    return Isolations;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnMuonPfRelIso03AllForJPsiMuonsInInvariantMass()\n",
    "{\n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    RVec_f Isolations {};\n",
    " \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "    \n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {\n",
    "                \n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                    \n",
    "                    if((im >= 90) && (im <= 120))\n",
    "                    {\n",
    "                        Isolations.push_back(this->JPsi_Muon_PfRelIso03_all[i]);\n",
    "                        Isolations.push_back(this->JPsi_Muon_PfRelIso03_all[j]);\n",
    "                    }\n",
    "                    \n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "                   \n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return Isolations;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiMassforJPsiInInvariantMass()\n",
    "{\n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float imAll = 0;\n",
    "    float imJPsi = 0;\n",
    "    \n",
    "    RVec_f ptAll {};\n",
    "    RVec_f etaAll {};\n",
    "    RVec_f phiAll {};\n",
    "    RVec_f massAll {};\n",
    "    \n",
    "    RVec_f JPsiMasses {};\n",
    " \n",
    "    for(int k = 0; k < this->Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "    \n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {\n",
    "                \n",
    "                    ptAll.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    etaAll.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phiAll.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    massAll.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    ptAll.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    etaAll.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phiAll.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    massAll.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    ptAll.push_back(this->Isolated_Muon_pt[k]);\n",
    "                    etaAll.push_back(this->Isolated_Muon_eta[k]);\n",
    "                    phiAll.push_back(this->Isolated_Muon_phi[k]);\n",
    "                    massAll.push_back(this->Isolated_Muon_mass[k]);\n",
    "                    \n",
    "                    \n",
    "                    imAll = ROOT::VecOps::InvariantMass(ptAll, etaAll, phiAll, massAll);\n",
    "                    \n",
    "                    if((imAll >= 90) && (imAll <= 120))\n",
    "                    {\n",
    "                    \n",
    "                        auto FourVector1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                        auto FourVector2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "\n",
    "                        auto FourVector3 = FourVector1 + FourVector2;\n",
    "                        \n",
    "                        JPsiMasses.push_back(FourVector3.M());\n",
    "\n",
    "                        FourVector1 = {};\n",
    "                        FourVector2 = {};\n",
    "                    }\n",
    "                    \n",
    "                    ptAll.clear();\n",
    "                    etaAll.clear();\n",
    "                    phiAll.clear();\n",
    "                    massAll.clear();\n",
    "                   \n",
    "                }\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return JPsiMasses;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaEtaBetweenIsolatedAndJPsiMuonCalculator()\n",
    "{ \n",
    "    float DeltaEtaIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaEtaRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_eta.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->JPsi_Muon_eta.size(); j++)\n",
    "        {\n",
    "                    \n",
    "                    DeltaEtaIndividual = this->Isolated_Muon_eta[i] - this->JPsi_Muon_eta[j];\n",
    "                    \n",
    "                    DeltaEtaRVec.push_back(DeltaEtaIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaEtaRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaPhiBetweenIsolatedAndJPsiMuonCalculator()\n",
    "{\n",
    "    float PhiIsolated = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float DeltaPhiIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaPhiRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->JPsi_Muon_phi.size(); j++)\n",
    "        {\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[i];\n",
    "\n",
    "                    PhiJPsi = this->JPsi_Muon_phi[j];\n",
    "\n",
    "                    DeltaPhiIndividual = ROOT::VecOps::DeltaPhi(PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    DeltaPhiRVec.push_back(DeltaPhiIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaPhiRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaRBetweenIsolatedAndJPsiMuonCalculator()\n",
    "{ \n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaRRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < this->JPsi_Muon_phi.size(); j++)\n",
    "        {    \n",
    "                    EtaIsolated = this->Isolated_Muon_eta[i];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[i];\n",
    "                    \n",
    "                    EtaJPsi = this->JPsi_Muon_eta[j];\n",
    "                    PhiJPsi = this->JPsi_Muon_phi[j];\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "\n",
    "                    DeltaRRVec.push_back(DeltaRIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaRRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaEtaBetweenJPsiMuonsCalculator()\n",
    "{\n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float DeltaEtaIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaEtaRVec {};\n",
    "    \n",
    "    /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "    for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "    {    \n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "        \n",
    "        /* If charges are opposite, calculate the invariant mass of them */\n",
    "        for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {                \n",
    "                DeltaEtaIndividual = this->JPsi_Muon_eta[i] - this->JPsi_Muon_eta[j];\n",
    "\n",
    "                DeltaEtaRVec.push_back(DeltaEtaIndividual);\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaEtaRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaPhiBetweenJPsiMuonsCalculator()\n",
    "{ \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float PhiJPsi1 = 0;\n",
    "    float PhiJPsi2 = 0;\n",
    "    \n",
    "    float DeltaPhiIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaPhiRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->JPsi_Muon_phi.size(); i++)\n",
    "    {\n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "        \n",
    "        for(int j = i+1; j < this->JPsi_Muon_phi.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {                \n",
    "                PhiJPsi1 = this->JPsi_Muon_phi[i];\n",
    "\n",
    "                PhiJPsi2 = this->JPsi_Muon_phi[j];\n",
    "\n",
    "                DeltaPhiIndividual = ROOT::VecOps::DeltaPhi(PhiJPsi1, PhiJPsi2);\n",
    "\n",
    "                DeltaPhiRVec.push_back(DeltaPhiIndividual);\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaPhiRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaRBetweenJPsiMuonsCalculator()\n",
    "{ \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float EtaJPsi1 = 0;\n",
    "    float PhiJPsi1 = 0;\n",
    "    float EtaJPsi2 = 0;\n",
    "    float PhiJPsi2 = 0;\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaRRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->JPsi_Muon_phi.size(); i++)\n",
    "    {\n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            for(int j = i+1; j < this->JPsi_Muon_phi.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {                \n",
    "                    EtaJPsi1 = this->JPsi_Muon_eta[i];\n",
    "                    PhiJPsi1 = this->JPsi_Muon_phi[i];\n",
    "                    \n",
    "                    EtaJPsi2 = this->JPsi_Muon_eta[j];\n",
    "                    PhiJPsi2 = this->JPsi_Muon_phi[j];\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaJPsi1, EtaJPsi2, PhiJPsi1, PhiJPsi2);\n",
    "\n",
    "                    DeltaRRVec.push_back(DeltaRIndividual);\n",
    "                }\n",
    "            }\n",
    "        }\n",
    "        \n",
    "    return DeltaRRVec;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnDeltaEtaBetweenJPsiMuonsInPeak()\n",
    "{\n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float DeltaEtaIndividual = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    RVec_f DeltaEtaRVec {};\n",
    "    \n",
    "    /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "    for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "    {    \n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "        \n",
    "        /* If charges are opposite, calculate the invariant mass of them */\n",
    "        for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                \n",
    "                if((ROOT::VecOps::InvariantMass(pt, eta, phi, mass) > 3.0) && (ROOT::VecOps::InvariantMass(pt, eta, phi, mass) < 3.2))\n",
    "                {            \n",
    "                    DeltaEtaIndividual = this->JPsi_Muon_eta[i] - this->JPsi_Muon_eta[j];\n",
    "\n",
    "                    DeltaEtaRVec.push_back(DeltaEtaIndividual);\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            pt.clear();\n",
    "            eta.clear();\n",
    "            phi.clear();\n",
    "            mass.clear();\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaEtaRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnDeltaPhiBetweenJPsiMuonsInPeak()\n",
    "{ \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float PhiJPsi1 = 0;\n",
    "    float PhiJPsi2 = 0;\n",
    "    \n",
    "    float DeltaPhiIndividual = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    RVec_f DeltaPhiRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->JPsi_Muon_phi.size(); i++)\n",
    "    {\n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "        \n",
    "        for(int j = i+1; j < this->JPsi_Muon_phi.size(); j++)\n",
    "        {\n",
    "            SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "            \n",
    "            if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                \n",
    "                if((ROOT::VecOps::InvariantMass(pt, eta, phi, mass) > 3.0) && (ROOT::VecOps::InvariantMass(pt, eta, phi, mass) < 3.2))\n",
    "                {\n",
    "                    PhiJPsi1 = this->JPsi_Muon_phi[i];\n",
    "\n",
    "                    PhiJPsi2 = this->JPsi_Muon_phi[j];\n",
    "\n",
    "                    DeltaPhiIndividual = ROOT::VecOps::DeltaPhi(PhiJPsi1, PhiJPsi2);\n",
    "\n",
    "                    DeltaPhiRVec.push_back(DeltaPhiIndividual);\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            pt.clear();\n",
    "            eta.clear();\n",
    "            phi.clear();\n",
    "            mass.clear();\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaPhiRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnDeltaRBetweenJPsiMuonsInPeak()\n",
    "{ \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float EtaJPsi1 = 0;\n",
    "    float PhiJPsi1 = 0;\n",
    "    float EtaJPsi2 = 0;\n",
    "    float PhiJPsi2 = 0;\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    RVec_f DeltaRRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->JPsi_Muon_phi.size(); i++)\n",
    "    {\n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            for(int j = i+1; j < this->JPsi_Muon_phi.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {                \n",
    "                    EtaJPsi1 = this->JPsi_Muon_eta[i];\n",
    "                    PhiJPsi1 = this->JPsi_Muon_phi[i];\n",
    "                    \n",
    "                    EtaJPsi2 = this->JPsi_Muon_eta[j];\n",
    "                    PhiJPsi2 = this->JPsi_Muon_phi[j];\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaJPsi1, EtaJPsi2, PhiJPsi1, PhiJPsi2);\n",
    "                    \n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "\n",
    "                    if((ROOT::VecOps::InvariantMass(pt, eta, phi, mass) > 3.0) && (ROOT::VecOps::InvariantMass(pt, eta, phi, mass) < 3.2))\n",
    "                    {\n",
    "                        DeltaRRVec.push_back(DeltaRIndividual);\n",
    "                    }\n",
    "                }\n",
    "                \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "        \n",
    "    return DeltaRRVec;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaEtaBetweenIsolatedMuonAndJPsiCalculator()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiFourVectorCalculator();\n",
    "    \n",
    "    float DeltaEtaIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaEtaRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_eta.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < FourVectorTotal.size(); j++)\n",
    "        {                    \n",
    "                    DeltaEtaIndividual = this->Isolated_Muon_eta[i] - FourVectorTotal.at(j).Eta();\n",
    "                    \n",
    "                    DeltaEtaRVec.push_back(DeltaEtaIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaEtaRVec;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaPhiBetweenIsolatedMuonAndJPsiCalculator()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiFourVectorCalculator();\n",
    "    \n",
    "    float PhiIsolated = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float DeltaPhiIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaPhiRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < FourVectorTotal.size(); j++)\n",
    "        {\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[i];\n",
    "                    PhiJPsi = FourVectorTotal.at(j).Phi();\n",
    "                    \n",
    "                    DeltaPhiIndividual = ROOT::VecOps::DeltaPhi(PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    DeltaPhiRVec.push_back(DeltaPhiIndividual);\n",
    "\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaPhiRVec;   \n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaRBetweenIsolatedMuonAndJPsiCalculator()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiFourVectorCalculator();\n",
    "    \n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaRRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < FourVectorTotal.size(); j++)\n",
    "        {    \n",
    "\n",
    "                    DeltaRRVec.push_back(DeltaRIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaRRVec;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnLowDeltaRIsolatedMuonAndJPsiMuonPt(bool ReturnJPsiMuon)\n",
    "{\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsiMuon = 0;\n",
    "    float PhiJPsiMuon = 0;\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_ff IsolatedMuonAndJPsiMuonPt {};\n",
    "    \n",
    "    RVec_f IsolatedMuonPt {};\n",
    "    RVec_f JPsiMuonPt {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_pt.size(); i++)\n",
    "    {    \n",
    "\n",
    "        for(int j = 0; j < this->JPsi_Muon_pt.size(); j++)\n",
    "        {\n",
    "                    EtaIsolated = this->Isolated_Muon_eta[i];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[i];\n",
    "                    \n",
    "                    EtaJPsiMuon = this->JPsi_Muon_eta[j];\n",
    "                    PhiJPsiMuon = this->JPsi_Muon_phi[j];\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsiMuon, PhiIsolated, PhiJPsiMuon);\n",
    "\n",
    "                    if(DeltaRIndividual > 2)\n",
    "                    {\n",
    "                        IsolatedMuonAndJPsiMuonPt.push_back(std::tuple(this->Isolated_Muon_pt[i], this->JPsi_Muon_pt[j]));\n",
    "                    }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    if(!ReturnJPsiMuon)\n",
    "    {\n",
    "        for(int m = 0; m < IsolatedMuonAndJPsiMuonPt.size(); m++)\n",
    "        {\n",
    "            IsolatedMuonPt.push_back(std::get<0>(IsolatedMuonAndJPsiMuonPt[m]));\n",
    "        }\n",
    "        \n",
    "        return IsolatedMuonPt;\n",
    "    }\n",
    "    \n",
    "    else\n",
    "    {\n",
    "        for(int m = 0; m < IsolatedMuonAndJPsiMuonPt.size(); m++)\n",
    "        {\n",
    "            JPsiMuonPt.push_back(std::get<1>(IsolatedMuonAndJPsiMuonPt[m]));\n",
    "        }\n",
    "        \n",
    "        return JPsiMuonPt;\n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiInPeakMass()\n",
    "{\n",
    "    RVec_f JPsiInPeakMass = {};\n",
    "    \n",
    "    RVec_FourVector FourVectorTotal = JPsiForMuonsInPeakFourVectorCalculator();\n",
    "    \n",
    "    for(int i = 0; i < FourVectorTotal.size(); i++)\n",
    "    {\n",
    "        JPsiInPeakMass.push_back(FourVectorTotal.at(i).M());\n",
    "    }\n",
    "    \n",
    "    return JPsiInPeakMass;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiMuonPtInPeak()\n",
    "{\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    RVec_f JPsiMuonPt {};\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    for(int k = 0; k < this->Isolated_Muon_charge.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                    SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                    \n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "        \n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                    dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "                    \n",
    "                    im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                    \n",
    "                    if((im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (dr > dr_cut) && (im_three > three_body_im_cut))\n",
    "                    {\n",
    "                        JPsiMuonPt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                        JPsiMuonPt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    }\n",
    "\n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return JPsiMuonPt;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiMuonEtaInPeak()\n",
    "{\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "\n",
    "    RVec_f JPsiMuonEta {};\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    for(int k = 0; k < this->Isolated_Muon_charge.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                    SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                    \n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "                    \n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                    dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "                    \n",
    "                    im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "\n",
    "                    if((im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (dr > dr_cut) && (im_three > three_body_im_cut))\n",
    "                    {\n",
    "                        JPsiMuonEta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                        JPsiMuonEta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    }\n",
    "\n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return JPsiMuonEta;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiMuonPhiInPeak()\n",
    "{\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "\n",
    "    RVec_f JPsiMuonPhi {};\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    for(int k = 0; k < this->Isolated_Muon_charge.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                    SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                    \n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                    \n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "                    \n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                    dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                    eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                    phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                    mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "                    \n",
    "                    im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "\n",
    "                    if((im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (dr > dr_cut) && (im_three > three_body_im_cut))\n",
    "                    {\n",
    "                        JPsiMuonPhi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                        JPsiMuonPhi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    }\n",
    "\n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return JPsiMuonPhi;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiMuonChargeInPeak()\n",
    "{\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f JPsiMuonCharge {};\n",
    "    \n",
    "    for(int k = 0; k < this->Isolated_Muon_charge.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < this->JPsi_Muon_phi.size(); i++)\n",
    "        {\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "                for(int j = i+1; j < this->JPsi_Muon_phi.size(); j++)\n",
    "                {\n",
    "                    SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                    if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                    {             \n",
    "                        pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                        eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                        phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                        mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                        pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                        eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                        phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                        mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                        \n",
    "                        auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                        auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                        auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                        \n",
    "                        EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                        PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                        EtaJPsi = JPsi.Eta();\n",
    "                        PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                        im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                        dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                        \n",
    "                        pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                        eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                        phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                        mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                        im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "\n",
    "                        if((im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (dr > dr_cut) && (im_three > three_body_im_cut))\n",
    "                        {\n",
    "                            JPsiMuonCharge.push_back(FirstMuonCharge);\n",
    "                            JPsiMuonCharge.push_back(SecondMuonCharge);\n",
    "                        }\n",
    "                    }\n",
    "\n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "                }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    return JPsiMuonCharge;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiInPeakPt()\n",
    "{\n",
    "    RVec_f JPsiPt = {};\n",
    "    \n",
    "    RVec_FourVector FourVectorTotal = JPsiForMuonsInPeakFourVectorCalculator();\n",
    "    \n",
    "    for(int i = 0; i < FourVectorTotal.size(); i++)\n",
    "    {\n",
    "        JPsiPt.push_back(FourVectorTotal.at(i).Pt());\n",
    "    }\n",
    "    \n",
    "    return JPsiPt;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiMuonPtInPeak(bool ReturnPositiveMuon)\n",
    "{\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsiMuon = 0;\n",
    "    float PhiJPsiMuon = 0;\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_ff IsolatedMuonAndJPsiMuonPt {};\n",
    "    \n",
    "    RVec_f JPsiMuonPositivePt {};\n",
    "    RVec_f JPsiMuonNegativePt {};\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "    {\n",
    "        FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "        for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "        {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "                \n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "                    \n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "\n",
    "                if((ROOT::VecOps::InvariantMass(pt, eta, phi, mass) > 3.0) && (ROOT::VecOps::InvariantMass(pt, eta, phi, mass) < 3.2) )\n",
    "                {\n",
    "                    if(FirstMuonCharge < 0)\n",
    "                    {\n",
    "                        JPsiMuonPositivePt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                        JPsiMuonNegativePt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    }\n",
    "                    \n",
    "                    else\n",
    "                    {\n",
    "                        JPsiMuonPositivePt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                        JPsiMuonNegativePt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    }\n",
    "                }\n",
    "                \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    if(ReturnPositiveMuon)\n",
    "    {        \n",
    "        return JPsiMuonPositivePt;\n",
    "    }\n",
    "    \n",
    "    else\n",
    "    {        \n",
    "        return JPsiMuonNegativePt;\n",
    "    }\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnJPsiMuonInPeakPfRelIso03All()\n",
    "{\n",
    "    int FirstMuonCharge = 0;\n",
    "    int SecondMuonCharge = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    RVec_f Isolations {};\n",
    "    \n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    " \n",
    "        /* Loop over the set of muons to determine which muons have +1 charge, then match them with all the ones with -1 charge. */\n",
    "        for(int i = 0; i < this->JPsi_Muon_charge.size(); i++)\n",
    "        {    \n",
    "\n",
    "            FirstMuonCharge = this->JPsi_Muon_charge[i];\n",
    "\n",
    "            /* If charges are opposite, calculate the invariant mass of them */\n",
    "            for(int j = i+1; j < this->JPsi_Muon_charge.size(); j++)\n",
    "            {\n",
    "                SecondMuonCharge = this->JPsi_Muon_charge[j];\n",
    "\n",
    "                if(FirstMuonCharge * SecondMuonCharge == -1)\n",
    "                {\n",
    "                \n",
    "                    pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                    pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                    eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                    phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                    mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "\n",
    "                    im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                    \n",
    "                    if((im >= 3.0) && (im <= 3.2))\n",
    "                    {\n",
    "                        Isolations.push_back(this->JPsi_Muon_PfRelIso03_all[i]);\n",
    "                        Isolations.push_back(this->JPsi_Muon_PfRelIso03_all[j]);\n",
    "                    }\n",
    "                    \n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "                   \n",
    "                }\n",
    "            }\n",
    "        }\n",
    "        \n",
    "    return Isolations;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::ReturnTopQuarkInPeakMass()\n",
    "{\n",
    "    RVec_f TopQuarkInPeakMass = {};\n",
    "    \n",
    "    RVec_FourVector FourVectorTotal = ThreeBodyInPeakFourVectorCalculator();\n",
    "    \n",
    "    for(int i = 0; i < FourVectorTotal.size(); i++)\n",
    "    {\n",
    "        TopQuarkInPeakMass.push_back(FourVectorTotal.at(i).M());\n",
    "    }\n",
    "    \n",
    "    return TopQuarkInPeakMass;\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaEtaBetweenIsolatedMuonAndJPsiInPeakCalculator()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiForMuonsInPeakFourVectorCalculator();\n",
    "    \n",
    "    float DeltaEtaIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaEtaRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_eta.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < FourVectorTotal.size(); j++)\n",
    "        {    \n",
    "                    DeltaEtaIndividual = this->Isolated_Muon_eta[i] - FourVectorTotal.at(j).Eta();\n",
    "                    \n",
    "                    DeltaEtaRVec.push_back(DeltaEtaIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaEtaRVec;\n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaPhiBetweenIsolatedMuonAndJPsiInPeakCalculator()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiForMuonsInPeakFourVectorCalculator();\n",
    "    \n",
    "    float PhiIsolated = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    float DeltaPhiIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaPhiRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < FourVectorTotal.size(); j++)\n",
    "        {    \n",
    "                    PhiIsolated = this->Isolated_Muon_phi[i];\n",
    "\n",
    "                    PhiJPsi = FourVectorTotal.at(j).Phi();\n",
    "\n",
    "                    DeltaPhiIndividual = ROOT::VecOps::DeltaPhi(PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    DeltaPhiRVec.push_back(DeltaPhiIndividual);\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return DeltaPhiRVec;   \n",
    "}\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::DeltaRBetweenIsolatedMuonAndJPsiInPeakCalculator()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiForMuonsInPeakFourVectorCalculator();\n",
    "    \n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaRRVec {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < FourVectorTotal.size(); j++)\n",
    "        {\n",
    "            EtaIsolated = this->Isolated_Muon_eta[i];\n",
    "            PhiIsolated = this->Isolated_Muon_phi[i];\n",
    "                    \n",
    "            EtaJPsi = FourVectorTotal.at(j).Eta();\n",
    "            PhiJPsi = FourVectorTotal.at(j).Phi();\n",
    "        \n",
    "            DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "\n",
    "            DeltaRRVec.push_back(DeltaRIndividual);\n",
    "\n",
    "        }\n",
    "    }\n",
    "\n",
    "    return DeltaRRVec;\n",
    "}\n",
    "\n",
    "\n",
    "RVec_f MuonAndJPsiStatisticsAndKinematics::IsolatedMuonAndJPsiInPeakCalculator()\n",
    "{\n",
    "    RVec_FourVector FourVectorTotal = JPsiForMuonsInPeakFourVectorCalculator();\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "    \n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f InvariantMasses {};\n",
    "    \n",
    "    for(int i = 0; i < this->Isolated_Muon_phi.size(); i++)\n",
    "    {\n",
    "    \n",
    "        for(int j = 0; j < FourVectorTotal.size(); j++)\n",
    "        {    \n",
    "                    pt.push_back(this->Isolated_Muon_pt[i]);\n",
    "                    eta.push_back(this->Isolated_Muon_eta[i]);\n",
    "                    phi.push_back(this->Isolated_Muon_phi[i]);\n",
    "                    mass.push_back(this->Isolated_Muon_mass[i]);\n",
    "                    \n",
    "                    pt.push_back(FourVectorTotal.at(j).Pt());\n",
    "                    eta.push_back(FourVectorTotal.at(j).Eta());\n",
    "                    phi.push_back(FourVectorTotal.at(j).Phi());\n",
    "                    mass.push_back(FourVectorTotal.at(j).M());\n",
    "\n",
    "                    InvariantMasses.push_back(ROOT::VecOps::InvariantMass(pt, eta, phi, mass));\n",
    "                    \n",
    "                    pt.clear();\n",
    "                    eta.clear();\n",
    "                    phi.clear();\n",
    "                    mass.clear();\n",
    "        }\n",
    "    }\n",
    "        \n",
    "    return InvariantMasses;\n",
    "}\n",
    "\n",
    "\"\"\"\n",
    "ROOT.gInterpreter.Declare(cpp_code_1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "a91d34cf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cpp_code_2 = \"\"\"\n",
    "class ParticleDecayChain\n",
    "{\n",
    "    private:\n",
    "        RVec_i IsolatedMuon_reco_id;\n",
    "        RVec_i JPsiMuon_reco_id;\n",
    "        RVec_i GenPart_pdgId;\n",
    "        RVec_i GenPart_genPartIdxMother;\n",
    "        RVec_f JPsi_Muon_pt;\n",
    "        RVec_f JPsi_Muon_eta;\n",
    "        RVec_f JPsi_Muon_phi;\n",
    "        RVec_f JPsi_Muon_mass;\n",
    "        RVec_i JPsi_Muon_charge;\n",
    "        RVec_f Isolated_Muon_pt;\n",
    "        RVec_f Isolated_Muon_eta;\n",
    "        RVec_f Isolated_Muon_phi;\n",
    "        RVec_f Isolated_Muon_mass;\n",
    "        RVec_i Isolated_Muon_charge;\n",
    "        RVec_f GenPart_pt;\n",
    "        float Ht;\n",
    "        int NumJets;\n",
    "        \n",
    "    public:\n",
    "        ParticleDecayChain();\n",
    "        ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge);\n",
    "        ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f GenPart_pt);\n",
    "        ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f GenPart_pt, float Ht);\n",
    "        ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f GenPart_pt, float Ht, int NumJets);\n",
    "\n",
    "        RVec_f DeltaRDataPlaceholder();\n",
    "        RVec_i PurityCalculator(bool higher);\n",
    "        RVec_f ParentPtCalculator(bool higher, bool SameParentMuons);\n",
    "        RVec_f ParentPtCalculatorHt(bool higher, bool SameParentMuons);\n",
    "        RVec_f ParentPtCalculatorNumJets(bool higher, bool SameParentMuons);\n",
    "        RVec_f DeltaRAndHtSelector(bool ReturnDeltaR);\n",
    "\n",
    "};\n",
    "\n",
    "ParticleDecayChain::ParticleDecayChain()\n",
    "{\n",
    "    this->IsolatedMuon_reco_id = {};\n",
    "    this->JPsiMuon_reco_id = {};\n",
    "    this->GenPart_pdgId = {};\n",
    "    this->GenPart_genPartIdxMother = {};\n",
    "    this->JPsi_Muon_pt = {};\n",
    "    this->JPsi_Muon_eta = {};\n",
    "    this->JPsi_Muon_phi = {};\n",
    "    this->JPsi_Muon_mass = {};\n",
    "    this->JPsi_Muon_charge = {};\n",
    "    this->Isolated_Muon_pt = {};\n",
    "    this->Isolated_Muon_eta = {};\n",
    "    this->Isolated_Muon_phi = {};\n",
    "    this->Isolated_Muon_mass = {};\n",
    "    this->Isolated_Muon_charge = {};\n",
    "    this->GenPart_pt = {};\n",
    "    this->Ht = 0;\n",
    "    this->NumJets = 0;\n",
    "}\n",
    "\n",
    "ParticleDecayChain::ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge)\n",
    "{\n",
    "    this->IsolatedMuon_reco_id = IsolatedMuon_reco_id;\n",
    "    this->JPsiMuon_reco_id = JPsiMuon_reco_id;\n",
    "    this->GenPart_pdgId = GenPart_pdgId;\n",
    "    this->GenPart_genPartIdxMother = GenPart_genPartIdxMother;\n",
    "    this->JPsi_Muon_pt = JPsi_Muon_pt;\n",
    "    this->JPsi_Muon_eta = JPsi_Muon_eta;\n",
    "    this->JPsi_Muon_phi = JPsi_Muon_phi;\n",
    "    this->JPsi_Muon_mass = JPsi_Muon_mass;\n",
    "    this->JPsi_Muon_charge = JPsi_Muon_charge;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "    this->GenPart_pt = {};\n",
    "    this->Ht = 0;\n",
    "    this->NumJets = 0;\n",
    "}\n",
    "\n",
    "ParticleDecayChain::ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f GenPart_pt)\n",
    "{\n",
    "    this->IsolatedMuon_reco_id = IsolatedMuon_reco_id;\n",
    "    this->JPsiMuon_reco_id = JPsiMuon_reco_id;\n",
    "    this->GenPart_pdgId = GenPart_pdgId;\n",
    "    this->GenPart_genPartIdxMother = GenPart_genPartIdxMother;\n",
    "    this->JPsi_Muon_pt = JPsi_Muon_pt;\n",
    "    this->JPsi_Muon_eta = JPsi_Muon_eta;\n",
    "    this->JPsi_Muon_phi = JPsi_Muon_phi;\n",
    "    this->JPsi_Muon_mass = JPsi_Muon_mass;\n",
    "    this->JPsi_Muon_charge = JPsi_Muon_charge;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "    this->GenPart_pt = GenPart_pt;\n",
    "    this->Ht = 0;\n",
    "    this->NumJets = 0;\n",
    "}\n",
    "\n",
    "ParticleDecayChain::ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f GenPart_pt, float Ht)\n",
    "{\n",
    "    this->IsolatedMuon_reco_id = IsolatedMuon_reco_id;\n",
    "    this->JPsiMuon_reco_id = JPsiMuon_reco_id;\n",
    "    this->GenPart_pdgId = GenPart_pdgId;\n",
    "    this->GenPart_genPartIdxMother = GenPart_genPartIdxMother;\n",
    "    this->JPsi_Muon_pt = JPsi_Muon_pt;\n",
    "    this->JPsi_Muon_eta = JPsi_Muon_eta;\n",
    "    this->JPsi_Muon_phi = JPsi_Muon_phi;\n",
    "    this->JPsi_Muon_mass = JPsi_Muon_mass;\n",
    "    this->JPsi_Muon_charge = JPsi_Muon_charge;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "    this->GenPart_pt = GenPart_pt;\n",
    "    this->Ht = Ht;\n",
    "    this->NumJets = 0;\n",
    "}\n",
    "\n",
    "ParticleDecayChain::ParticleDecayChain(RVec_i IsolatedMuon_reco_id, RVec_i JPsiMuon_reco_id, RVec_i GenPart_pdgId, RVec_i GenPart_genPartIdxMother, RVec_f JPsi_Muon_pt, RVec_f JPsi_Muon_eta, RVec_f JPsi_Muon_phi, RVec_f JPsi_Muon_mass, RVec_i JPsi_Muon_charge, RVec_f Isolated_Muon_pt, RVec_f Isolated_Muon_eta, RVec_f Isolated_Muon_phi, RVec_f Isolated_Muon_mass, RVec_i Isolated_Muon_charge, RVec_f GenPart_pt, float Ht, int NumJets)\n",
    "{\n",
    "    this->IsolatedMuon_reco_id = IsolatedMuon_reco_id;\n",
    "    this->JPsiMuon_reco_id = JPsiMuon_reco_id;\n",
    "    this->GenPart_pdgId = GenPart_pdgId;\n",
    "    this->GenPart_genPartIdxMother = GenPart_genPartIdxMother;\n",
    "    this->JPsi_Muon_pt = JPsi_Muon_pt;\n",
    "    this->JPsi_Muon_eta = JPsi_Muon_eta;\n",
    "    this->JPsi_Muon_phi = JPsi_Muon_phi;\n",
    "    this->JPsi_Muon_mass = JPsi_Muon_mass;\n",
    "    this->JPsi_Muon_charge = JPsi_Muon_charge;\n",
    "    this->Isolated_Muon_pt = Isolated_Muon_pt;\n",
    "    this->Isolated_Muon_eta = Isolated_Muon_eta;\n",
    "    this->Isolated_Muon_phi = Isolated_Muon_phi;\n",
    "    this->Isolated_Muon_mass = Isolated_Muon_mass;\n",
    "    this->Isolated_Muon_charge = Isolated_Muon_charge;\n",
    "    this->GenPart_pt = GenPart_pt;\n",
    "    this->Ht = Ht;\n",
    "    this->NumJets = NumJets;\n",
    "}\n",
    "\n",
    "RVec_f ParticleDecayChain::DeltaRDataPlaceholder()\n",
    "{\n",
    "    return {};\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "RVec_i ParticleDecayChain::PurityCalculator(bool higher)\n",
    "{\n",
    "    int TargetPDGId = 6;\n",
    "    \n",
    "    RVec_i IsolatedMuonTargetIndex = {};\n",
    "    RVec_i JPsiMuonTargetIndex = {};\n",
    "    \n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuon_reco_id.size(); k++)\n",
    "    {\n",
    "    \n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "        \n",
    "        int CurrentIndex = IsolatedMuon_reco_id[k];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "            \n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "        \n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        IsolatedMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "\n",
    "    \n",
    "    for(int j = 0; j < JPsiMuon_reco_id.size(); j++)\n",
    "    {\n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "\n",
    "        int CurrentIndex = JPsiMuon_reco_id[j];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "\n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "\n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        JPsiMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "    const float dr_cutoff = 2.5;\n",
    "\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "\n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_i PurityVector = {};    \n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuonTargetIndex.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < JPsiMuonTargetIndex.size(); i++)\n",
    "        {\n",
    "            for(int j = i + 1; j < JPsiMuonTargetIndex.size(); j++)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                        \n",
    "                auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                        \n",
    "                EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                EtaJPsi = JPsi.Eta();\n",
    "                PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                        \n",
    "                pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                        \n",
    "                if((this->JPsi_Muon_charge[i] * this->JPsi_Muon_charge[j] == -1) && (im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (dr < dr_cut) && (im_three > three_body_im_cut))\n",
    "                {\n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "\n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    if(!higher)\n",
    "                    {\n",
    "                        if(DeltaRIndividual < dr_cutoff)\n",
    "                        {\n",
    "                            if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1))\n",
    "                            {\n",
    "                                PurityVector.push_back(1);\n",
    "                            }\n",
    "\n",
    "                            else\n",
    "                            {\n",
    "                                PurityVector.push_back(-1);\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                    \n",
    "                    else\n",
    "                    {\n",
    "                        if(DeltaRIndividual > dr_cutoff)\n",
    "                        {\n",
    "                            if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1))\n",
    "                            {\n",
    "                                PurityVector.push_back(-1);\n",
    "                            }\n",
    "\n",
    "                            else\n",
    "                            {\n",
    "                                PurityVector.push_back(1);\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                }\n",
    "                \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "\n",
    "    return PurityVector;    \n",
    "}\n",
    "\n",
    "\n",
    "RVec_f ParticleDecayChain::ParentPtCalculator(bool higher, bool SameParentMuons)\n",
    "{\n",
    "    int TargetPDGId = 6;\n",
    "    \n",
    "    RVec_i IsolatedMuonTargetIndex = {};\n",
    "    RVec_i JPsiMuonTargetIndex = {};\n",
    "    \n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuon_reco_id.size(); k++)\n",
    "    {\n",
    "    \n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "        \n",
    "        int CurrentIndex = IsolatedMuon_reco_id[k];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "            \n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "        \n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        IsolatedMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "\n",
    "    \n",
    "    for(int j = 0; j < JPsiMuon_reco_id.size(); j++)\n",
    "    {\n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "\n",
    "        int CurrentIndex = JPsiMuon_reco_id[j];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "\n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "\n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        JPsiMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "    const float dr_cutoff = 2.5;\n",
    "\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "\n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f ParentPtVector = {};\n",
    "    \n",
    "    bool MuonAlreadyAccountedFor = false;\n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuonTargetIndex.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < JPsiMuonTargetIndex.size(); i++)\n",
    "        {\n",
    "            for(int j = i + 1; j < JPsiMuonTargetIndex.size(); j++)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                        \n",
    "                auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                        \n",
    "                EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                EtaJPsi = JPsi.Eta();\n",
    "                PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                        \n",
    "                pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                        \n",
    "                if((this->JPsi_Muon_charge[i] * this->JPsi_Muon_charge[j] == -1) && (im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (im_three > three_body_im_cut))\n",
    "                {\n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "\n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    if(!higher)\n",
    "                    {\n",
    "                        if(DeltaRIndividual < dr_cutoff)\n",
    "                        {\n",
    "                            if(SameParentMuons)\n",
    "                            {\n",
    "                                if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                }\n",
    "                            }\n",
    "                            \n",
    "                            else\n",
    "                            {\n",
    "                                if(!((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j])) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                    \n",
    "                                    MuonAlreadyAccountedFor = true;\n",
    "                                }\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                    \n",
    "                    else\n",
    "                    {\n",
    "                        if(DeltaRIndividual > dr_cutoff)\n",
    "                        {\n",
    "                            if(SameParentMuons)\n",
    "                            {\n",
    "                                if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                }\n",
    "                            }\n",
    "                            \n",
    "                            else\n",
    "                            {\n",
    "                                if(!((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j])) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[JPsiMuonTargetIndex[i]]);\n",
    "                                    \n",
    "                                    MuonAlreadyAccountedFor = true;\n",
    "                                }\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                }\n",
    "                \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "                \n",
    "                if(MuonAlreadyAccountedFor)\n",
    "                {\n",
    "                    break;\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            /* Use this code segment if trying to find the Pt for Isolated Muons with a different top parent than the J/Psi Muons; ignore if interested in J/Psi Muons */\n",
    "            if(MuonAlreadyAccountedFor)\n",
    "            {\n",
    "                break;\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "\n",
    "    return ParentPtVector;    \n",
    "}\n",
    "\n",
    "\n",
    "RVec_f ParticleDecayChain::ParentPtCalculatorHt(bool higher, bool SameParentMuons)\n",
    "{\n",
    "    int TargetPDGId = 6;\n",
    "    \n",
    "    RVec_i IsolatedMuonTargetIndex = {};\n",
    "    RVec_i JPsiMuonTargetIndex = {};\n",
    "    \n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuon_reco_id.size(); k++)\n",
    "    {\n",
    "    \n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "        \n",
    "        int CurrentIndex = IsolatedMuon_reco_id[k];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "            \n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "        \n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        IsolatedMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "\n",
    "    \n",
    "    for(int j = 0; j < JPsiMuon_reco_id.size(); j++)\n",
    "    {\n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "\n",
    "        int CurrentIndex = JPsiMuon_reco_id[j];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "\n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "\n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        JPsiMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "    const float ht_cutoff = 300;\n",
    "\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "\n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f ParentPtVector = {};\n",
    "    \n",
    "    bool MuonAlreadyAccountedFor = false;\n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuonTargetIndex.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < JPsiMuonTargetIndex.size(); i++)\n",
    "        {\n",
    "            for(int j = i + 1; j < JPsiMuonTargetIndex.size(); j++)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                        \n",
    "                auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                        \n",
    "                EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                EtaJPsi = JPsi.Eta();\n",
    "                PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                        \n",
    "                pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                        \n",
    "                if((this->JPsi_Muon_charge[i] * this->JPsi_Muon_charge[j] == -1) && (im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (im_three > three_body_im_cut))\n",
    "                {\n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "\n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    if(!higher)\n",
    "                    {\n",
    "                        if(this->Ht < ht_cutoff)\n",
    "                        {\n",
    "                            if(SameParentMuons)\n",
    "                            {\n",
    "                                if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                }\n",
    "                            }\n",
    "                            \n",
    "                            else\n",
    "                            {\n",
    "                                if(!((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j])) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[JPsiMuonTargetIndex[i]]);\n",
    "                                    \n",
    "                                    MuonAlreadyAccountedFor = true;\n",
    "                                }\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                    \n",
    "                    else\n",
    "                    {\n",
    "                        if(this->Ht > ht_cutoff)\n",
    "                        {\n",
    "                            if(SameParentMuons)\n",
    "                            {\n",
    "                                if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                }\n",
    "                            }\n",
    "                            \n",
    "                            else\n",
    "                            {\n",
    "                                if(!((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j])) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                    \n",
    "                                    MuonAlreadyAccountedFor = true;\n",
    "                                }\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                }\n",
    "                \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "                \n",
    "                if(MuonAlreadyAccountedFor)\n",
    "                {\n",
    "                    break;\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            /* Use this code segment if trying to find the Pt for Isolated Muons with a different top parent than the J/Psi Muons; ignore if interested in J/Psi Muons*/\n",
    "            if(MuonAlreadyAccountedFor)\n",
    "            {\n",
    "                break;\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "\n",
    "    return ParentPtVector;    \n",
    "}\n",
    "\n",
    "RVec_f ParticleDecayChain::ParentPtCalculatorNumJets(bool higher, bool SameParentMuons)\n",
    "{\n",
    "    int TargetPDGId = 6;\n",
    "    \n",
    "    RVec_i IsolatedMuonTargetIndex = {};\n",
    "    RVec_i JPsiMuonTargetIndex = {};\n",
    "    \n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuon_reco_id.size(); k++)\n",
    "    {\n",
    "    \n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "        \n",
    "        int CurrentIndex = IsolatedMuon_reco_id[k];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "            \n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "        \n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        IsolatedMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "\n",
    "    \n",
    "    for(int j = 0; j < JPsiMuon_reco_id.size(); j++)\n",
    "    {\n",
    "        RVec_f GenPartMotherIdxChain = {};\n",
    "        RVec_f GenPartPDGIdChain = {};\n",
    "\n",
    "        int CurrentIndex = JPsiMuon_reco_id[j];\n",
    "        \n",
    "        int TargetIndex = -1;\n",
    "        \n",
    "        GenPartMotherIdxChain.push_back(CurrentIndex);\n",
    "        \n",
    "        while(CurrentIndex != -1)\n",
    "        {\n",
    "            GenPartMotherIdxChain.push_back(this->GenPart_genPartIdxMother[CurrentIndex]);\n",
    "            \n",
    "            if((this->GenPart_pdgId[CurrentIndex] == TargetPDGId) || (this->GenPart_pdgId[CurrentIndex] == TargetPDGId * -1))\n",
    "            {\n",
    "                TargetIndex = CurrentIndex;\n",
    "            }\n",
    "\n",
    "            CurrentIndex = this->GenPart_genPartIdxMother[CurrentIndex];\n",
    "        }\n",
    "\n",
    "        GenPartPDGIdChain.push_back(TargetIndex);\n",
    "        \n",
    "        JPsiMuonTargetIndex.push_back(TargetIndex);\n",
    "    }\n",
    "\n",
    "    const float num_jets_cutoff = 4;\n",
    "\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "\n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f ParentPtVector = {};\n",
    "    \n",
    "    bool MuonAlreadyAccountedFor = false;\n",
    "    \n",
    "    for(int k = 0; k < IsolatedMuonTargetIndex.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < JPsiMuonTargetIndex.size(); i++)\n",
    "        {\n",
    "            for(int j = i + 1; j < JPsiMuonTargetIndex.size(); j++)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                        \n",
    "                auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                        \n",
    "                EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                EtaJPsi = JPsi.Eta();\n",
    "                PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                        \n",
    "                pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                        \n",
    "                if((this->JPsi_Muon_charge[i] * this->JPsi_Muon_charge[j] == -1) && (im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (im_three > three_body_im_cut))\n",
    "                {\n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "\n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    if(!higher)\n",
    "                    {\n",
    "                        if(this->NumJets < num_jets_cutoff)\n",
    "                        {\n",
    "                            if(SameParentMuons)\n",
    "                            {\n",
    "                                if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                }\n",
    "                            }\n",
    "                            \n",
    "                            else\n",
    "                            {\n",
    "                                if(!((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j])) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[JPsiMuonTargetIndex[i]]);\n",
    "                                    \n",
    "                                    MuonAlreadyAccountedFor = true;\n",
    "                                }\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                    \n",
    "                    else\n",
    "                    {\n",
    "                        if(this->NumJets >= num_jets_cutoff)\n",
    "                        {\n",
    "                            if(SameParentMuons)\n",
    "                            {\n",
    "                                if((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j]) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[IsolatedMuonTargetIndex[k]]);\n",
    "                                }\n",
    "                            }\n",
    "                            \n",
    "                            else\n",
    "                            {\n",
    "                                if(!((IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[i]) && (IsolatedMuonTargetIndex[k] == JPsiMuonTargetIndex[j])) && (IsolatedMuonTargetIndex[k] != -1) && (JPsiMuonTargetIndex[i] != -1) && (JPsiMuonTargetIndex[j] != -1))\n",
    "                                {\n",
    "                                    ParentPtVector.push_back(GenPart_pt[JPsiMuonTargetIndex[i]]);\n",
    "                                    \n",
    "                                    MuonAlreadyAccountedFor = true;\n",
    "                                }\n",
    "                            }\n",
    "                        }\n",
    "                    }\n",
    "                }\n",
    "                \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "                \n",
    "                if(MuonAlreadyAccountedFor)\n",
    "                {\n",
    "                    break;\n",
    "                }\n",
    "            }\n",
    "            \n",
    "            /* Use this code segment if trying to find the Pt for Isolated Muons with a different top parent than the J/Psi Muons; ignore if interested in J/Psi Muons\n",
    "            if(MuonAlreadyAccountedFor)\n",
    "            {\n",
    "                break;\n",
    "            }*/\n",
    "        }\n",
    "    }\n",
    "\n",
    "    return ParentPtVector;    \n",
    "}\n",
    "\n",
    "/* This function picks out Delta R values for events with Ht values in a certain range. */\n",
    "RVec_f ParticleDecayChain::DeltaRAndHtSelector(bool ReturnDeltaR)\n",
    "{\n",
    "    const float ht_cutoff = 300;\n",
    "\n",
    "    float EtaIsolated = 0;\n",
    "    float PhiIsolated = 0;\n",
    "    float EtaJPsi = 0;\n",
    "    float PhiJPsi = 0;\n",
    "    \n",
    "    float im = 0;\n",
    "    float dr = 0;\n",
    "    float im_three = 0;\n",
    "    \n",
    "    RVec_f pt {};\n",
    "    RVec_f eta {};\n",
    "    RVec_f phi {};\n",
    "    RVec_f mass {};\n",
    "\n",
    "    float DeltaRIndividual = 0;\n",
    "    \n",
    "    RVec_f DeltaRRVector = {};\n",
    "    RVec_f HtRVector = {};\n",
    "    \n",
    "    for(int k = 0; k < Isolated_Muon_pt.size(); k++)\n",
    "    {\n",
    "        for(int i = 0; i < JPsi_Muon_pt.size(); i++)\n",
    "        {\n",
    "            for(int j = i + 1; j < JPsi_Muon_pt.size(); j++)\n",
    "            {\n",
    "                pt.push_back(this->JPsi_Muon_pt[i]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[i]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[i]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[i]);\n",
    "\n",
    "                pt.push_back(this->JPsi_Muon_pt[j]);\n",
    "                eta.push_back(this->JPsi_Muon_eta[j]);\n",
    "                phi.push_back(this->JPsi_Muon_phi[j]);\n",
    "                mass.push_back(this->JPsi_Muon_mass[j]);\n",
    "                        \n",
    "                auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "                        \n",
    "                EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                EtaJPsi = JPsi.Eta();\n",
    "                PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                im = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                dr = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                        \n",
    "                pt.push_back(this->Isolated_Muon_pt[k]);\n",
    "                eta.push_back(this->Isolated_Muon_eta[k]);\n",
    "                phi.push_back(this->Isolated_Muon_phi[k]);\n",
    "                mass.push_back(this->Isolated_Muon_mass[k]);\n",
    "\n",
    "                im_three = ROOT::VecOps::InvariantMass(pt, eta, phi, mass);\n",
    "                        \n",
    "                if((this->JPsi_Muon_charge[i] * this->JPsi_Muon_charge[j] == -1) && (im > low_jpsi_im_cut) && (im < high_jpsi_im_cut) && (im_three > three_body_im_cut))\n",
    "                {\n",
    "                    auto JPsiMuon1 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[i], this->JPsi_Muon_eta[i], this->JPsi_Muon_phi[i], this->JPsi_Muon_mass[i]);\n",
    "                    auto JPsiMuon2 = ROOT::Math::PtEtaPhiMVector (this->JPsi_Muon_pt[j], this->JPsi_Muon_eta[j], this->JPsi_Muon_phi[j], this->JPsi_Muon_mass[j]);\n",
    "                    auto JPsi = JPsiMuon1 + JPsiMuon2;\n",
    "\n",
    "                    EtaIsolated = this->Isolated_Muon_eta[k];\n",
    "                    PhiIsolated = this->Isolated_Muon_phi[k];\n",
    "\n",
    "                    EtaJPsi = JPsi.Eta();\n",
    "                    PhiJPsi = JPsi.Phi();\n",
    "\n",
    "                    DeltaRIndividual = ROOT::VecOps::DeltaR(EtaIsolated, EtaJPsi, PhiIsolated, PhiJPsi);\n",
    "                    \n",
    "                    if(this->Ht > ht_cutoff)\n",
    "                    {\n",
    "                        DeltaRRVector.push_back(DeltaRIndividual);\n",
    "\n",
    "                        HtRVector.push_back(this->Ht);\n",
    "                    }\n",
    "                    \n",
    "                }\n",
    "                \n",
    "                pt.clear();\n",
    "                eta.clear();\n",
    "                phi.clear();\n",
    "                mass.clear();\n",
    "\n",
    "            }\n",
    "        }\n",
    "    }\n",
    "    \n",
    "    if(ReturnDeltaR)\n",
    "    {\n",
    "        return DeltaRRVector;\n",
    "    }\n",
    "    \n",
    "    else\n",
    "    {\n",
    "        return HtRVector;\n",
    "    }\n",
    "}\n",
    "\"\"\"\n",
    "ROOT.gInterpreter.Declare(cpp_code_2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "ce5dd994",
   "metadata": {},
   "outputs": [],
   "source": [
    "def IsolatedLeptonSelection():\n",
    "\n",
    "    for sample in dictOfListOfFiles:       \n",
    "\n",
    "        rdfPassedIsolatedLeptonTrigger[sample] = rdf[sample].Filter(\"HLT_IsoMu24 == true ||(HLT_Ele32_WPTight_Gsf == true && HLT_IsoMu24 == false)\", \"HLTLeptonTrigger\")\\\n",
    "            .Define(\"LumiXS\",wgtFormula[sample])\\\n",
    "            .Define(\"leading_isolated_muon_mask\", LeadingIsolatedMuonMask)\\\n",
    "            .Define(\"leading_isolated_electron_mask\", LeadingIsolatedElectronMask)\n",
    "\n",
    "        if sample == 'gen_data':\n",
    "            rdfIsolatedMuonNoHighWeights[sample] = rdfPassedIsolatedLeptonTrigger[sample].Filter(\"Sum(leading_isolated_muon_mask) == 1 && Sum(leading_isolated_electron_mask) == 0\", \"Exactly one isolated muon and exactly zero isolated electrons\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_pt\", \"Muon_pt[leading_isolated_muon_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_eta\", \"Muon_eta[leading_isolated_muon_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_phi\", \"Muon_phi[leading_isolated_muon_mask].at(0, -5)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_mass\", \"Muon_mass[leading_isolated_muon_mask].at(0, -2.71)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_charge\", \"Muon_charge[leading_isolated_muon_mask].at(0, -5)\")\\\n",
    "                .Define(\"IsolatedMuon_pt\", \"Muon_pt[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_eta\", \"Muon_eta[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_phi\", \"Muon_phi[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_mass\", \"Muon_mass[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_charge\", \"Muon_charge[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_pdgId\", \"Muon_pdgId[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pt\", \"Electron_pt[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_eta\", \"Electron_eta[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_phi\", \"Electron_phi[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_mass\", \"Electron_mass[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_charge\", \"Electron_charge[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pdgId\", \"Electron_pdgId[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedLepton_pt\", \"Concatenate(IsolatedMuon_pt, IsolatedElectron_pt)\")\\\n",
    "                .Define(\"IsolatedLepton_eta\", \"Concatenate(IsolatedMuon_eta, IsolatedElectron_eta)\")\\\n",
    "                .Define(\"IsolatedLepton_phi\", \"Concatenate(IsolatedMuon_phi, IsolatedElectron_phi)\")\\\n",
    "                .Define(\"IsolatedLepton_mass\", \"Concatenate(IsolatedMuon_mass, IsolatedElectron_mass)\")\\\n",
    "                .Define(\"IsolatedLepton_charge\", \"Concatenate(IsolatedMuon_charge, IsolatedElectron_charge)\")\\\n",
    "                .Define(\"IsolatedLepton_pdgid\", \"Concatenate(IsolatedMuon_pdgId, IsolatedElectron_pdgId)\")\\\n",
    "                .Define(\"METBeforeMETCut\", \"MET_pt\")\n",
    "            \n",
    "            rdfIsolatedElectronNoHighWeights[sample] = rdfPassedIsolatedLeptonTrigger[sample].Filter(\"Sum(leading_isolated_electron_mask) == 1 && Sum(leading_isolated_muon_mask) == 0\", \"Exactly one isolated electron and exactly zero isolated muon\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_pt\", \"Electron_pt[leading_isolated_electron_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_eta\", \"Electron_eta[leading_isolated_electron_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_phi\", \"Electron_phi[leading_isolated_electron_mask].at(0, -5)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_mass\", \"Electron_mass[leading_isolated_electron_mask].at(0, -2.71)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_charge\", \"Electron_charge[leading_isolated_electron_mask].at(0, -5)\")\\\n",
    "                .Define(\"IsolatedMuon_pt\", \"Muon_pt[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_eta\", \"Muon_eta[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_phi\", \"Muon_phi[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_mass\", \"Muon_mass[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_charge\", \"Muon_charge[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_pdgId\", \"Muon_pdgId[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pt\", \"Electron_pt[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_eta\", \"Electron_eta[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_phi\", \"Electron_phi[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_mass\", \"Electron_mass[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_charge\", \"Electron_charge[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pdgId\", \"Electron_pdgId[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedLepton_pt\", \"Concatenate(IsolatedMuon_pt, IsolatedElectron_pt)\")\\\n",
    "                .Define(\"IsolatedLepton_eta\", \"Concatenate(IsolatedMuon_eta, IsolatedElectron_eta)\")\\\n",
    "                .Define(\"IsolatedLepton_phi\", \"Concatenate(IsolatedMuon_phi, IsolatedElectron_phi)\")\\\n",
    "                .Define(\"IsolatedLepton_mass\", \"Concatenate(IsolatedMuon_mass, IsolatedElectron_mass)\")\\\n",
    "                .Define(\"IsolatedLepton_charge\", \"Concatenate(IsolatedMuon_charge, IsolatedElectron_charge)\")\\\n",
    "                .Define(\"IsolatedLepton_pdgid\", \"Concatenate(IsolatedMuon_pdgId, IsolatedElectron_pdgId)\")\\\n",
    "                .Define(\"METBeforeMETCut\", \"MET_pt\")\n",
    "\n",
    "\n",
    "        # Change criteria to nothing below or above 4 standard deviations from the mean\n",
    "        else:\n",
    "            rdfIsolatedMuonNoHighWeights[sample] = rdfPassedIsolatedLeptonTrigger[sample].Filter(\"genWeight < 1000 && Sum(leading_isolated_muon_mask) == 1 && Sum(leading_isolated_electron_mask) == 0\", \"Exactly one isolated muon and exactly zero isolated electrons\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_pt\", \"Muon_pt[leading_isolated_muon_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_eta\", \"Muon_eta[leading_isolated_muon_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_phi\", \"Muon_phi[leading_isolated_muon_mask].at(0, -5)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_mass\", \"Muon_mass[leading_isolated_muon_mask].at(0, -2.71)\")\\\n",
    "                .Define(\"LeadingIsolatedMuon_charge\", \"Muon_charge[leading_isolated_muon_mask].at(0, -5)\")\\\n",
    "                .Define(\"IsolatedMuon_pt\", \"Muon_pt[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_eta\", \"Muon_eta[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_phi\", \"Muon_phi[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_mass\", \"Muon_mass[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_charge\", \"Muon_charge[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_pdgId\", \"Muon_pdgId[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_reco_id\", \"Muon_genPartIdx[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pt\", \"Electron_pt[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_eta\", \"Electron_eta[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_phi\", \"Electron_phi[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_mass\", \"Electron_mass[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_charge\", \"Electron_charge[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pdgId\", \"Electron_pdgId[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedLepton_pt\", \"Concatenate(IsolatedMuon_pt, IsolatedElectron_pt)\")\\\n",
    "                .Define(\"IsolatedLepton_eta\", \"Concatenate(IsolatedMuon_eta, IsolatedElectron_eta)\")\\\n",
    "                .Define(\"IsolatedLepton_phi\", \"Concatenate(IsolatedMuon_phi, IsolatedElectron_phi)\")\\\n",
    "                .Define(\"IsolatedLepton_mass\", \"Concatenate(IsolatedMuon_mass, IsolatedElectron_mass)\")\\\n",
    "                .Define(\"IsolatedLepton_charge\", \"Concatenate(IsolatedMuon_charge, IsolatedElectron_charge)\")\\\n",
    "                .Define(\"IsolatedLepton_pdgid\", \"Concatenate(IsolatedMuon_pdgId, IsolatedElectron_pdgId)\")\\\n",
    "                .Define(\"METBeforeMETCut\", \"MET_pt\")\n",
    "\n",
    "            rdfIsolatedElectronNoHighWeights[sample] = rdfPassedIsolatedLeptonTrigger[sample].Filter(\"genWeight < 1000 && Sum(leading_isolated_electron_mask) == 1 && Sum(leading_isolated_muon_mask) == 0\", \"Exactly one isolated electron and exactly zero isolated muon\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_pt\", \"Electron_pt[leading_isolated_electron_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_eta\", \"Electron_eta[leading_isolated_electron_mask].at(0, -10)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_phi\", \"Electron_phi[leading_isolated_electron_mask].at(0, -5)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_mass\", \"Electron_mass[leading_isolated_electron_mask].at(0, -2.71)\")\\\n",
    "                .Define(\"LeadingIsolatedElectron_charge\", \"Electron_charge[leading_isolated_electron_mask].at(0, -5)\")\\\n",
    "                .Define(\"IsolatedMuon_pt\", \"Muon_pt[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_eta\", \"Muon_eta[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_phi\", \"Muon_phi[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_mass\", \"Muon_mass[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_charge\", \"Muon_charge[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedMuon_pdgId\", \"Muon_pdgId[leading_isolated_muon_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pt\", \"Electron_pt[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_eta\", \"Electron_eta[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_phi\", \"Electron_phi[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_mass\", \"Electron_mass[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_charge\", \"Electron_charge[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedElectron_pdgId\", \"Electron_pdgId[leading_isolated_electron_mask]\")\\\n",
    "                .Define(\"IsolatedLepton_pt\", \"Concatenate(IsolatedMuon_pt, IsolatedElectron_pt)\")\\\n",
    "                .Define(\"IsolatedLepton_eta\", \"Concatenate(IsolatedMuon_eta, IsolatedElectron_eta)\")\\\n",
    "                .Define(\"IsolatedLepton_phi\", \"Concatenate(IsolatedMuon_phi, IsolatedElectron_phi)\")\\\n",
    "                .Define(\"IsolatedLepton_mass\", \"Concatenate(IsolatedMuon_mass, IsolatedElectron_mass)\")\\\n",
    "                .Define(\"IsolatedLepton_charge\", \"Concatenate(IsolatedMuon_charge, IsolatedElectron_charge)\")\\\n",
    "                .Define(\"IsolatedLepton_pdgid\", \"Concatenate(IsolatedMuon_pdgId, IsolatedElectron_pdgId)\")\\\n",
    "                .Define(\"METBeforeMETCut\", \"MET_pt\")\n",
    "\n",
    "        rdfIsolatedMuonAfterMETCut[sample] = rdfIsolatedMuonNoHighWeights[sample].Filter(\"MET_pt > 30\", \"Muon MET Greater than 30 GeV\")\\\n",
    "            .Define(\"METAfterMETCut\", \"MET_pt\")\\\n",
    "            .Define(\"IsolatedMuon_pfRelIso03_all\", \"Muon_pfRelIso03_all[leading_isolated_muon_mask]\")\\\n",
    "            .Define(\"jet_mask\", \"ROOT::VecOps::RVec<Int_t> jmask = (Jet_pt >= 30 && abs(Jet_eta) <= 2.5 && Jet_jetId >= 2); \"\\\n",
    "                        \"for(int i=0; i < IsolatedLepton_pt.size(); ++i){\"\\\n",
    "                            \"ROOT::VecOps::RVec<Float_t> dr;\"\\\n",
    "                            \"for(int j=0; j < jmask.size(); ++j){\"\\\n",
    "                                \"dr.push_back(ROOT::VecOps::DeltaR(Jet_eta.at(j), IsolatedLepton_eta.at(i), Jet_phi.at(j), IsolatedLepton_phi.at(i)));}\"\\\n",
    "                                \"jmask = jmask && dr >= 0.4;\"\\\n",
    "                                \"dr.clear();}\"\\\n",
    "                        \"return jmask;\")\\\n",
    "            .Define(\"Num_Jets\", \"Jet_pt[jet_mask].size()\")\n",
    "        \n",
    "        rdfIsolatedElectronAfterMETCut[sample] = rdfIsolatedElectronNoHighWeights[sample].Filter(\"MET_pt > 30\", \"Electron MET Greater than 30 GeV\")\\\n",
    "            .Define(\"METAfterMETCut\", \"MET_pt\")\n",
    "        \n",
    "    return rdfIsolatedMuonAfterMETCut, rdfIsolatedElectronAfterMETCut"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "54881930",
   "metadata": {},
   "outputs": [],
   "source": [
    "rdfIsolatedMuonAfterMETCut, rdfIsolatedElectronAfterMETCut = IsolatedLeptonSelection()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "0ea54eba",
   "metadata": {},
   "outputs": [],
   "source": [
    "def JetSelection():\n",
    "\n",
    "    for sample in dictOfListOfFiles:\n",
    "        \n",
    "        rdfJetAndIsolatedLeptonFiltered[sample] = rdfIsolatedMuonAfterMETCut[sample].Filter(\"Num_Jets >= 3\", \"At Least Two Jets\")\\\n",
    "            .Define(\"SJet1_pt\", \"Jet_pt[jet_mask].size() > 0 ? Jet_pt[jet_mask].at(0) : -500\")\\\n",
    "            .Define(\"SJet2_pt\", \"Jet_pt[jet_mask].size() > 1 ? Jet_pt[jet_mask].at(1) : -500\")\\\n",
    "            .Define(\"SJet1_eta\", \"Jet_eta[jet_mask].size() > 0 ? Jet_eta[jet_mask].at(0) : 500\")\\\n",
    "            .Define(\"SJet2_eta\", \"Jet_eta[jet_mask].size() > 1 ? Jet_eta[jet_mask].at(1) : 500\")\\\n",
    "            .Define(\"SJet1_phi\", \"Jet_phi[jet_mask].size() > 0 ? Jet_phi[jet_mask].at(0) : 500\")\\\n",
    "            .Define(\"SJet2_phi\", \"Jet_phi[jet_mask].size() > 1 ? Jet_phi[jet_mask].at(1) : 500\")\\\n",
    "            .Define(\"MTofMETandMu\", \"FTA::transverseMassMET(IsolatedMuon_pt, IsolatedMuon_phi, IsolatedMuon_mass, MET_pt, MET_phi)\")\\\n",
    "            .Define(\"Ht\", \"Sum(Jet_pt[jet_mask])\")\\\n",
    "            .Define(\"jpsi_mu_candidate_mask\", JPsiMuonCandidateMask)\\\n",
    "            .Define(\"JPsiMuonCandidate_pt\", \"Muon_pt[jpsi_mu_candidate_mask]\")\\\n",
    "            .Define(\"JPsiMuonCandidate_eta\", \"Muon_eta[jpsi_mu_candidate_mask]\")\\\n",
    "            .Define(\"JPsiMuonCandidate_phi\", \"Muon_phi[jpsi_mu_candidate_mask]\")\\\n",
    "            .Define(\"JPsiMuonCandidate_mass\", \"Muon_mass[jpsi_mu_candidate_mask]\")\\\n",
    "            .Define(\"JPsiMuonCandidate_charge\", \"Muon_charge[jpsi_mu_candidate_mask]\")\\\n",
    "            .Define(\"MuonCorrectIMDR\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.IsOppositeChargeCorrectIM();\")\\\n",
    "            .Define(\"jpsi_correct_im_dr_mask\", JPsiMuonCorrectIMDR)\\\n",
    "            .Define(\"Num_JPsi_Muons\", \"Muon_pt[jpsi_mu_candidate_mask].size()\")\n",
    "      \n",
    "    return rdfJetAndIsolatedLeptonFiltered"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "4c8da657",
   "metadata": {},
   "outputs": [],
   "source": [
    "rdfJetAndIsolatedLeptonFiltered = JetSelection()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "30a9ba45",
   "metadata": {},
   "outputs": [],
   "source": [
    "def JPsiSelection():\n",
    "\n",
    "    for sample in dictOfListOfFiles:\n",
    "\n",
    "        rdfJPsiMuons[sample] = rdfJetAndIsolatedLeptonFiltered[sample].Filter(\"Sum(jpsi_mu_candidate_mask) >= 2 && Sum(jpsi_correct_im_dr_mask) >= 1\", \"Events with JPsis and Isolated Muons with Correct DeltaR\")\\\n",
    "            .Define(\"InvariantMassJPsiMuons\", \"std::cout << rdfentry_ << std::endl; auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.JPsiMuonInvariantMassCalculator();\")\\\n",
    "            .Define(\"InvariantMassJPsiMuonsAndIsolatedMuons\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.IsolatedMuonAndJPsiInPeakCalculator();\")\\\n",
    "            .Define(\"DeltaEtaBetweenIsolatedAndJPsiMuon\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaEtaBetweenIsolatedAndJPsiMuonCalculator();\")\\\n",
    "            .Define(\"DeltaPhiBetweenIsolatedAndJPsiMuon\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaPhiBetweenIsolatedAndJPsiMuonCalculator();\")\\\n",
    "            .Define(\"DeltaRBetweenIsolatedAndJPsiMuon\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaRBetweenIsolatedAndJPsiMuonCalculator();\")\\\n",
    "            .Define(\"JPsi_pt\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.ReturnJPsiPt();\")\\\n",
    "            .Define(\"JPsi_eta\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.ReturnJPsiEta();\")\\\n",
    "            .Define(\"JPsi_phi\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.ReturnJPsiPhi();\")\\\n",
    "            .Define(\"DeltaEtaBetweenJPsiMuons\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.DeltaEtaBetweenJPsiMuonsCalculator();\")\\\n",
    "            .Define(\"DeltaPhiBetweenJPsiMuons\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.DeltaPhiBetweenJPsiMuonsCalculator();\")\\\n",
    "            .Define(\"DeltaRBetweenJPsiMuons\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.DeltaRBetweenJPsiMuonsCalculator();\")\\\n",
    "            .Define(\"DeltaRBetweenJPsiMuonsInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge); return c.ReturnDeltaRBetweenJPsiMuonsInPeak();\")\\\n",
    "            .Define(\"DeltaEtaBetweenIsolatedMuonAndJPsi\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaEtaBetweenIsolatedMuonAndJPsiCalculator();\")\\\n",
    "            .Define(\"DeltaPhiBetweenIsolatedMuonAndJPsi\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaPhiBetweenIsolatedMuonAndJPsiCalculator();\")\\\n",
    "            .Define(\"DeltaRBetweenIsolatedMuonAndJPsi\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaRBetweenIsolatedMuonAndJPsiCalculator();\")\\\n",
    "            .Define(\"JPsiMuon_pfRelIso03_all\", \"Muon_pfRelIso03_all[jpsi_mu_candidate_mask]\")\\\n",
    "            .Define(\"JPsiMuon_pfIsoid\", \"Muon_pfIsoId[jpsi_mu_candidate_mask]\")\\\n",
    "            .Define(\"IsolatedMuonsInRangeInvariantMassPlot_pfRelIso03_all\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, Muon_pfRelIso03_all[leading_isolated_muon_mask], Muon_pfRelIso03_all[jpsi_mu_candidate_mask]); return c.ReturnMuonPfRelIso03AllForIsolatedMuonInInvariantMass();\")\\\n",
    "            .Define(\"JPsiMuonsInRangeInvariantMassPlot_pfRelIso03_all\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, Muon_pfRelIso03_all[leading_isolated_muon_mask], Muon_pfRelIso03_all[jpsi_mu_candidate_mask]); return c.ReturnMuonPfRelIso03AllForJPsiMuonsInInvariantMass();\")\\\n",
    "            .Define(\"JPsiMassesInRangeInvariantMassPlot\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiMassforJPsiInInvariantMass()\")\\\n",
    "            .Define(\"IsolatedMuonPtAtLowDeltaR\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnLowDeltaRIsolatedMuonAndJPsiMuonPt(false)\")\\\n",
    "            .Define(\"JPsiMuonPtAtLowDeltaR\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnLowDeltaRIsolatedMuonAndJPsiMuonPt(true)\")\\\n",
    "            .Define(\"JPsiMassInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiInPeakMass();\")\\\n",
    "            .Define(\"DeltaEtaForJPsiMuonsInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnDeltaEtaBetweenJPsiMuonsInPeak();\")\\\n",
    "            .Define(\"DeltaPhiForJPsiMuonsInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnDeltaPhiBetweenJPsiMuonsInPeak();\")\\\n",
    "            .Define(\"DeltaRForJPsiMuonsInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnDeltaRBetweenJPsiMuonsInPeak();\")\\\n",
    "            .Define(\"JPsiMuon_pt\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiMuonPtInPeak();\")\\\n",
    "            .Define(\"JPsiMuon_eta\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiMuonEtaInPeak();\")\\\n",
    "            .Define(\"JPsiMuon_phi\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiMuonPhiInPeak();\")\\\n",
    "            .Define(\"JPsiMuon_charge\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiMuonChargeInPeak();\")\\\n",
    "            .Define(\"JPsiPtWithMuonInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiInPeakPt();\")\\\n",
    "            .Define(\"JPsiMuonPositivePt\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiMuonPtInPeak(true);\")\\\n",
    "            .Define(\"JPsiMuonNegativePt\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnJPsiMuonPtInPeak(false);\")\\\n",
    "            .Define(\"JPsiMuonIsolationInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, Muon_pfRelIso03_all[leading_isolated_muon_mask], Muon_pfRelIso03_all[jpsi_mu_candidate_mask]); return c.ReturnJPsiMuonInPeakPfRelIso03All();\")\\\n",
    "            .Define(\"DeltaEtaBetweenIsolatedMuonAndJPsiInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaEtaBetweenIsolatedMuonAndJPsiInPeakCalculator();\")\\\n",
    "            .Define(\"DeltaPhiBetweenIsolatedMuonAndJPsiInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaPhiBetweenIsolatedMuonAndJPsiInPeakCalculator();\")\\\n",
    "            .Define(\"DeltaRBetweenIsolatedMuonAndJPsiInPeak\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.DeltaRBetweenIsolatedMuonAndJPsiInPeakCalculator();\")\\\n",
    "            .Define(\"Num_JPsi\", \"auto c = MuonAndJPsiStatisticsAndKinematics(JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.ReturnNumJPsis();\")\n",
    "\n",
    "        \n",
    "    return rdfJPsiMuons"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "bf6a961e",
   "metadata": {},
   "outputs": [],
   "source": [
    "rdfJPsiMuon = JPsiSelection()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "db8e8024",
   "metadata": {},
   "outputs": [],
   "source": [
    "def MCTruthCalculator():\n",
    "    \n",
    "    for sample in dictOfListOfFiles:\n",
    "        \n",
    "        if sample == 'gen_data':\n",
    "            rdfMCTruth[sample] = rdfJPsiMuons[sample]\\\n",
    "                .Define(\"MCTruthPurityDeltaRLowerRVec\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"MCTruthPurityDeltaRHigherRVec\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"ParentTopPtSameParent\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"ParentTopPtDifferentParent\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"ParentTopPtSameParentHt\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"ParentTopPtDifferentParentHt\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"ParentTopPtSameParentNumJets\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"ParentTopPtDifferentParentNumJets\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"DeltaRBetweenIsolatedMuonAndJPsiInPeakWithHtInRange\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\\\n",
    "                .Define(\"HtInRange\", \"auto c = ParticleDecayChain(); return c.DeltaRDataPlaceholder();\")\n",
    "            \n",
    "        else:\n",
    "            rdfMCTruth[sample] = rdfJPsiMuons[sample]\\\n",
    "                .Define(\"JPsiMuon_reco_id\", \"Muon_genPartIdx[jpsi_mu_candidate_mask]\")\\\n",
    "                .Define(\"MCTruthPurityDeltaRLowerRVec\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.PurityCalculator(false);\")\\\n",
    "                .Define(\"MCTruthPurityDeltaRHigherRVec\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge); return c.PurityCalculator(true);\")\\\n",
    "                .Define(\"ParentTopPtSameParent\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt); return c.ParentPtCalculator(false, true);\")\\\n",
    "                .Define(\"ParentTopPtDifferentParent\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt); return c.ParentPtCalculator(false, false);\")\\\n",
    "                .Define(\"ParentTopPtSameParentHt\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt, Ht); return c.ParentPtCalculatorHt(true, true);\")\\\n",
    "                .Define(\"ParentTopPtDifferentParentHt\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt, Ht); return c.ParentPtCalculatorHt(true, false);\")\\\n",
    "                .Define(\"ParentTopPtSameParentNumJets\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt, Ht, Num_Jets); return c.ParentPtCalculatorNumJets(false, true);\")\\\n",
    "                .Define(\"ParentTopPtDifferentParentNumJets\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt, Ht, Num_Jets); return c.ParentPtCalculatorNumJets(false, false);\")\\\n",
    "                .Define(\"DeltaRBetweenIsolatedMuonAndJPsiInPeakWithHtInRange\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt, Ht); return c.DeltaRAndHtSelector(true);\")\\\n",
    "                .Define(\"HtInRange\", \"auto c = ParticleDecayChain(IsolatedMuon_reco_id, JPsiMuon_reco_id, GenPart_pdgId, GenPart_genPartIdxMother, JPsiMuonCandidate_pt, JPsiMuonCandidate_eta, JPsiMuonCandidate_phi, JPsiMuonCandidate_mass, JPsiMuonCandidate_charge, IsolatedMuon_pt, IsolatedMuon_eta, IsolatedMuon_phi, IsolatedMuon_mass, IsolatedMuon_charge, GenPart_pt, Ht); return c.DeltaRAndHtSelector(false);\")\n",
    "\n",
    "    return rdfMCTruth"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "9bc9453b",
   "metadata": {},
   "outputs": [],
   "source": [
    "rdfMCTruth = MCTruthCalculator()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "352c067b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Make this block a function with the inputs as the nodes we want to attach histograms to (2-17-22)\n",
    "# rdfWithFourMomentum needs to be changed to whatever our final RDataFrame is (5-23-22)\n",
    "\n",
    "for sample in dictOfListOfFiles:\n",
    "    \n",
    "    if sample not in hist.keys():\n",
    "        hist[sample] = {}\n",
    "        report[sample] = rdf[sample].Report()\n",
    "        #nparraynode[sample] = rdfLeadingMuon[sample]\n",
    "        \n",
    "    if sample == 'gen_data':\n",
    "        \n",
    "        hist['gen_data'][\"leading_isolated_muon_pt_initial\"] = rdfIsolatedMuonNoHighWeights['gen_data'].Histo1D((\"leading_isolated_muon_pt_initial\",\"Leading Isolated Muon Transverse Momentum (One Muon, No Electrons); Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_eta_initial\"] = rdfIsolatedMuonNoHighWeights['gen_data'].Histo1D((\"leading_isolated_muon_eta_initial\", \"Leading Isolated Muon Pseudorapidity (One Muon, No Electrons); Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_phi_initial\"] = rdfIsolatedMuonNoHighWeights['gen_data'].Histo1D((\"leading_isolated_muon_phi_initial\", \"Leading Isolated Muon Angle (One Muon, No Electrons); Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_mass_initial\"] = rdfIsolatedMuonNoHighWeights['gen_data'].Histo1D((\"leading_isolated_muon_mass_initial\", \"Leading Isolated Muon Mass (One Muon, No Electrons); Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_charge_initial\"] = rdfIsolatedMuonNoHighWeights['gen_data'].Histo1D((\"leading_isolated_muon_charge_initial\", \"Leading Isolated Muon Charge (One Muon, No Electrons); Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_pt_initial\"] = rdfIsolatedElectronNoHighWeights['gen_data'].Histo1D((\"leading_isolated_electron_pt_initial\",\"Leading Isolated Electron Transverse Momentum (One Electron, No Muons); Pt (GeV);Events\",100,20,220),\"LeadingIsolatedElectron_pt\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_eta_initial\"] = rdfIsolatedElectronNoHighWeights['gen_data'].Histo1D((\"leading_isolated_electron_eta_initial\", \"Leading Isolated Electron Pseudorapidity (One Electron, No Muons); Eta; Events\",100,-3,3),\"LeadingIsolatedElectron_eta\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_phi_initial\"] = rdfIsolatedElectronNoHighWeights['gen_data'].Histo1D((\"leading_isolated_electron_phi_initial\", \"Leading Isolated Electron Angle (One Electron, No Muons); Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedElectron_phi\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_mass_initial\"] = rdfIsolatedElectronNoHighWeights['gen_data'].Histo1D((\"leading_isolated_electron_mass_initial\", \"Leading Isolated Electron Mass (One Electron, No Muons); Mass(Gev); Events\",10,.0001,.001),\"LeadingIsolatedElectron_mass\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_charge_initial\"] = rdfIsolatedElectronNoHighWeights['gen_data'].Histo1D((\"leading_isolated_electron_charge_initial\", \"Leading Isolated Electron Charge (One Electron, No Muons); Charge; Events\",5,-2,2),\"LeadingIsolatedElectron_charge\")\n",
    "        \n",
    "        hist['gen_data'][\"met_before_met_cut\"] = rdfIsolatedMuonNoHighWeights['gen_data'].Histo1D((\"met_before_met_cut\", \"MET Before MET Cut; Pt (GeV); Events\",100,0,250),\"METBeforeMETCut\")\n",
    "        hist['gen_data'][\"met_after_met_cut\"] = rdfIsolatedMuonAfterMETCut['gen_data'].Histo1D((\"met_after_met_cut\", \"MET After MET Cut; Pt (GeV); Events\",100,0,250),\"METAfterMETCut\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_pt_after_met_cut\"] = rdfIsolatedMuonAfterMETCut['gen_data'].Histo1D((\"leading_isolated_muon_pt_after_met_cut\",\"Leading Isolated Muon Transverse Momentum After MET Cut; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_eta_after_met_cut\"] = rdfIsolatedMuonAfterMETCut['gen_data'].Histo1D((\"leading_isolated_muon_eta_after_met_cut\", \"Leading Isolated Muon Pseudorapidity After MET Cut; Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_phi_after_met_cut\"] = rdfIsolatedMuonAfterMETCut['gen_data'].Histo1D((\"leading_isolated_muon_phi_after_met_cut\", \"Leading Isolated Muon Angle After MET Cut; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_mass_after_met_cut\"] = rdfIsolatedMuonAfterMETCut['gen_data'].Histo1D((\"leading_isolated_muon_mass_after_met_cut\", \"Leading Isolated Muon Mass After MET Cut; Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_charge_after_met_cut\"] = rdfIsolatedMuonAfterMETCut['gen_data'].Histo1D((\"leading_isolated_muon_charge_after_met_cut\", \"Leading Isolated Muon Charge After MET Cut; Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_pt_after_met_cut\"] = rdfIsolatedElectronAfterMETCut['gen_data'].Histo1D((\"leading_isolated_electron_pt_after_met_cut\",\"Leading Isolated Electron Transverse Momentum After MET Cut; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedElectron_pt\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_eta_after_met_cut\"] = rdfIsolatedElectronAfterMETCut['gen_data'].Histo1D((\"leading_isolated_electron_eta_after_met_cut\", \"Leading Isolated Electron Pseudorapidity After MET Cut; Eta; Events\",100,-3,3),\"LeadingIsolatedElectron_eta\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_phi_after_met_cut\"] = rdfIsolatedElectronAfterMETCut['gen_data'].Histo1D((\"leading_isolated_electron_phi_after_met_cut\", \"Leading Isolated Electron Angle After MET Cut; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedElectron_phi\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_mass_after_met_cut\"] = rdfIsolatedElectronAfterMETCut['gen_data'].Histo1D((\"leading_isolated_electron_mass_after_met_cut\", \"Leading Isolated Electron Mass After MET Cut; Mass(Gev); Events\",10,.0001,.001),\"LeadingIsolatedElectron_mass\")\n",
    "        hist['gen_data'][\"leading_isolated_electron_charge_after_met_cut\"] = rdfIsolatedElectronAfterMETCut['gen_data'].Histo1D((\"leading_isolated_electron_charge_after_met_cut\", \"Leading Isolated Electron Charge After MET Cut; Charge; Events\",5,-2,2),\"LeadingIsolatedElectron_charge\")\n",
    "        \n",
    "        hist['gen_data'][\"number_of_jets_initial\"] = rdfIsolatedMuonAfterMETCut['gen_data'].Histo1D((\"number_of_jets_initial\", \"Number of Jets Before Jet Cut; Number Of Jets; Events\", 20, 0, 20), \"Num_Jets\")\n",
    "        hist['gen_data'][\"number_of_jets\"] = rdfJPsiMuons['gen_data'].Histo1D((\"number_of_jets\", \"Number Of Jets; Number Of Jets; Events\", 12, 0, 12), \"Num_Jets\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_pt_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered['gen_data'].Histo1D((\"leading_isolated_muon_pt_after_jet_cut\",\"Leading Isolated Muon Transverse Momentum After Jet Cut; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_eta_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered['gen_data'].Histo1D((\"leading_isolated_muon_eta_after_jet_cut\", \"Leading Isolated Muon Pseudorapidity After Jet Cut; Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_phi_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered['gen_data'].Histo1D((\"leading_isolated_muon_phi_after_jet_cut\", \"Leading Isolated Muon Angle After Jet Cut; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_mass_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered['gen_data'].Histo1D((\"leading_isolated_muon_mass_after_jet_cut\", \"Leading Isolated Muon Mass After Jet Cut; Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_charge_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered['gen_data'].Histo1D((\"leading_isolated_muon_charge_after_jet_cut\", \"Leading Isolated Muon Charge After Jet Cut; Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\")\n",
    "        \n",
    "        hist['gen_data'][\"number_of_jpsi_muons_initial\"] = rdfJPsiMuons['gen_data'].Histo1D((\"number_of_jpsi_muons_initial\", \"Number of JPsi Muons Before JPsi Muon Cut; Number of Muons; Events\",10,0,9), \"Num_JPsi_Muons\")\n",
    "        hist['gen_data'][\"number_of_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"number_of_jpsi_muons\", \"Number of JPsi Muons; Number of Muons; Events\",7,0,7), \"Num_JPsi_Muons\")\n",
    "        hist['gen_data'][\"number_of_jpsis\"] = rdfJPsiMuons['gen_data'].Histo1D((\"number_of_jpsis\", \"Number of JPsis; Number of JPsis; Events\",4,0,4), \"Num_JPsi\")\n",
    "\n",
    "        \n",
    "        # Final Results\n",
    "        hist['gen_data'][\"leading_isolated_muon_pt\"] = rdfJPsiMuons['gen_data'].Histo1D((\"leading_isolated_muon_pt\",\"Leading Isolated Muon Transverse Momentum; Pt (GeV);Events\",50,20,220),\"LeadingIsolatedMuon_pt\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_eta\"] = rdfJPsiMuons['gen_data'].Histo1D((\"leading_isolated_muon_eta\", \"Leading Isolated Muon Pseudorapidity; Eta; Events\",30,-3,3),\"LeadingIsolatedMuon_eta\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_phi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"leading_isolated_muon_phi\", \"Leading Isolated Muon Angle; Phi (Radians); Events\",30,-3.5,3.5),\"LeadingIsolatedMuon_phi\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_mass\"] = rdfJPsiMuons['gen_data'].Histo1D((\"leading_isolated_muon_mass\", \"Leading Isolated Muon Mass; Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\")\n",
    "        hist['gen_data'][\"leading_isolated_muon_charge\"] = rdfJPsiMuons['gen_data'].Histo1D((\"leading_isolated_muon_charge\", \"Leading Isolated Muon Charge; Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\")\n",
    "        hist['gen_data'][\"isolated_muon_pf_rel_iso_03_all\"] = rdfJPsiMuons['gen_data'].Histo1D(( \"isolated_muon_pf_rel_iso_03_all\", \"Isolated Muon PfRelIso03_All; Isolated Muon PfRelIso03_All; Events\", 25, 0, .25), \"IsolatedMuon_pfRelIso03_all\")\n",
    "        \n",
    "        hist['gen_data'][\"jet1_pt\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jet1_pt\", \"Jet Transverse Momentum for Leading Jet; Pt (GeV); Events\", 50, 20, 200), \"SJet1_pt\")         \n",
    "        hist['gen_data'][\"jet2_pt\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jet2_pt\", \"Jet Transverse Momentum for Subleading Jet; Pt (GeV); Events\", 50, 20, 200), \"SJet2_pt\")\n",
    "        hist['gen_data'][\"jet1_eta\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jet1_eta\", \"Jet Pseudorapidity for Leading Jet; Eta; Events\", 30, -3, 3), \"SJet1_eta\")\n",
    "        hist['gen_data'][\"jet2_eta\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jet2_eta\", \"Jet Pseudorapidity for Subleading Jet; Eta; Events\", 30, -3, 3), \"SJet2_eta\")\n",
    "        hist['gen_data'][\"jet1_phi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jet1_phi\", \"Jet Angle for Leading Jet; Phi (Radians); Events\", 30, -3.5, 3.5), \"SJet1_phi\")\n",
    "        hist['gen_data'][\"jet2_phi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jet2_phi\", \"Jet Angle for Subleading Jet; Phi (Radians); Events\", 30, -3.5, 3.5), \"SJet2_phi\")\n",
    "        hist['gen_data'][\"transverse_mass\"] = rdfJPsiMuons['gen_data'].Histo1D((\"transverse_mass\", \"Transverse Mass; Transverse Mass (GeV); Events\", 40, 0, 150), \"MTofMETandMu\")  \n",
    "        hist['gen_data'][\"ht\"] = rdfJPsiMuons['gen_data'].Histo1D((\"ht\", \"Ht; Ht; Events\", 50, 0, 1000), \"Ht\")\n",
    "        \n",
    "        hist['gen_data'][\"met\"] = rdfJPsiMuons['gen_data'].Histo1D((\"met\", \"MET; Pt (GeV); Events\",50,0,250),\"METAfterMETCut\")\n",
    "               \n",
    "        hist['gen_data'][\"invariant_mass_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"invariant_mass_jpsi_muons\", \"Invariant Masses for J/Psi Candidate Muons (Oppositely Charged); Invariant Masses; Events\", 100, .5, 12), \"InvariantMassJPsiMuons\")\n",
    "        hist['gen_data'][\"invariant_masses_zoomed\"] = rdfJPsiMuons['gen_data'].Histo1D((\"invariant_masses_zoomed\", \"Invariant Masses for J/Psi Candidate Muons (Oppositely Charged); Invariant Masses; Events\", 50, 2.8, 3.4), \"InvariantMassJPsiMuons\")\n",
    "        hist['gen_data'][\"invariant_mass_jpsi_muons_and_isolated_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"invariant_mass_jpsi_and_isolated_muons\", \"Invariant Masses for J/Psi And Isolated Muons; Invariant Masses; Events\", 40, 0, 200), \"InvariantMassJPsiMuonsAndIsolatedMuons\")\n",
    "        hist['gen_data'][\"delta_eta_between_isolated_and_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_eta_between_isolated_and_jpsi_muons\", \"Delta Eta for Isolated Muon - JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenIsolatedAndJPsiMuon\")\n",
    "        hist['gen_data'][\"delta_phi_between_isolated_and_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_phi_between_isolated_and_jpsi_muons\", \"Delta Phi for Isolated Muon - JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenIsolatedAndJPsiMuon\")\n",
    "        hist['gen_data'][\"delta_r_between_isolated_and_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_r_between_isolated_and_jpsi_muons\", \"Delta R for Isolated and JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaRBetweenIsolatedAndJPsiMuon\")\n",
    "        hist['gen_data'][\"jpsi_pt\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_pt\", \"Transverse Momentum for JPsi; Pt; Events\", 240, 0, 120), \"JPsi_pt\")\n",
    "        hist['gen_data'][\"jpsi_eta\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_eta\", \"Pseudorapidity for JPsi; Eta; Events\", 50, -3, 3), \"JPsi_eta\")\n",
    "        hist['gen_data'][\"jpsi_phi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_phi\", \"Angle for JPsi; Phi; Events\", 50, -3.5, 3.5), \"JPsi_phi\")\n",
    "        hist['gen_data'][\"delta_eta_between_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_eta_between_jpsi_muons\", \"Delta Eta for JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenJPsiMuons\")\n",
    "        hist['gen_data'][\"delta_phi_between_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_phi_between_jpsi_muons\", \"Delta Phi for JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenJPsiMuons\")\n",
    "        hist['gen_data'][\"delta_r_between_jpsi_muons\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_r_between_jpsi_muons\", \"Delta R for JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaRBetweenJPsiMuons\")\n",
    "        hist['gen_data'][\"delta_r_between_jpsi_muons_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_r_between_jpsi_muons_in_peak\", \"Delta R for JPsi Muons In Peak; Delta R; Events\", 50, 0, 1), \"DeltaRBetweenJPsiMuonsInPeak\")\n",
    "        hist['gen_data'][\"delta_eta_between_isolated_muon_and_jpsi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_eta_between_isolated_muon_and_jpsi\", \"Delta Eta for Isolated Muon And JPsi; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenIsolatedMuonAndJPsi\")\n",
    "        hist['gen_data'][\"delta_phi_between_isolated_muon_and_jpsi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_phi_between_isolated_muon_and_jpsi\", \"Delta Phi for Isolated Muon And JPsi; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenIsolatedMuonAndJPsi\")\n",
    "        hist['gen_data'][\"delta_r_between_isolated_muon_and_jpsi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_r_between_isolated_muon_and_jpsi\", \"Delta R for Isolated Muon And JPsi; Delta R; Events\", 50, 0, 6), \"DeltaRBetweenIsolatedMuonAndJPsi\")\n",
    "        \n",
    "\n",
    "        hist['gen_data'][\"jpsi_muon_pt\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muon_pt\", \"JPsi Muon Pt - Muon Id Medium, Iso Id Tight; JPsi Muon Pt; Events\", 100, 0, 100), \"JPsiMuon_pt\")\n",
    "        hist['gen_data'][\"jpsi_muon_pf_rel_iso_03_all\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muon_pf_rel_iso_03_all\", \"JPsi Muon Pf Rel Iso 03 All - Muon Id Medium, Iso Id Tight; JPsi Muon Pf Rel Iso 03 All; Events\", 50, 0, .5), \"JPsiMuon_pfRelIso03_all\")\n",
    "        hist['gen_data'][\"jpsi_muon_pf_iso_id\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muon_pf_iso_id\", \"JPsi Muon Pf Iso Id - Muon Id Medium, Iso Id Tight; JPsi Muon Pf Iso Id; Events\", 6, .5, 6.5), \"JPsiMuon_pfIsoid\")\n",
    "        hist['gen_data'][\"isolated_muons_in_range_pfRelIso03_all\"] = rdfJPsiMuons['gen_data'].Histo1D((\"isolated_muons_in_range_pfRelIso03_all\", \"PfRelIso03_All For Isolated Muons In 90-120 GeV Range; PfRelIso03_All; Events\", 50, 0, .5), \"IsolatedMuonsInRangeInvariantMassPlot_pfRelIso03_all\")\n",
    "        hist['gen_data'][\"jpsi_muons_in_range_pfRelIso03_all\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muons_in_range_pfRelIso03_all\", \"PfRelIso03_All For JPsi Muons In 90-120 GeV Range; PfRelIso03_All; Events\", 50, 0, .5), \"JPsiMuonsInRangeInvariantMassPlot_pfRelIso03_all\")\n",
    "        hist['gen_data'][\"jpsi_mass_muons_in_range\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_mass_muons_in_range\", \"JPsi Mass For JPsis In 90-120 GeV Range; JPsi Mass; Events\", 200, 0, 100), \"JPsiMassesInRangeInvariantMassPlot\")\n",
    "        hist['gen_data'][\"pt_at_low_delta_r\"] = rdfJPsiMuons['gen_data'].Histo2D((\"pt_at_low_delta_r\", \"Isolated Muon and JPsi Muon Pt at Delta R < 0.3; Isolated Muon Pt; JPsi Muon Pt; Events\", 100, 20, 220, 100, 0, 100), \"IsolatedMuonPtAtLowDeltaR\", \"JPsiMuonPtAtLowDeltaR\")\n",
    "        \n",
    "        \n",
    "        hist['gen_data'][\"jpsi_mass_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_mass_in_peak\", \"J/Psi Mass Made from Muons In Peak; J/Psi Mass; Events\", 40, 2.9, 3.3), \"JPsiMassInPeak\")\n",
    "        hist['gen_data'][\"delta_eta_for_jpsi_muons_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_eta_for_jpsi_muons_in_peak\", \"Delta Eta For J/Psi Muons In Peak; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaForJPsiMuonsInPeak\")\n",
    "        hist['gen_data'][\"delta_phi_for_jpsi_muons_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_phi_for_jpsi_muons_in_peak\", \"Delta Phi For J/Psi Muons In Peak; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiForJPsiMuonsInPeak\")\n",
    "        hist['gen_data'][\"delta_r_for_jpsi_muons_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_r_for_jpsi_muons_in_peak\", \"Delta R For J/Psi Muons In Peak; Delta R; Events\", 50, 0, 6), \"DeltaRForJPsiMuonsInPeak\")\n",
    "        hist['gen_data'][\"jpsi_muons_charge_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muons_charge_in_peak\", \"J/Psi Muons In Peak Charge; Charge; Events\", 5, -2, 2), \"JPsiMuon_charge\")\n",
    "        hist['gen_data'][\"jpsi_pt_with_muon_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_pt_with_muon_in_peak\", \"J/Psi Pt With Muons In Peak; Pt; Events\", 40, 0, 200), \"JPsiPtWithMuonInPeak\")  \n",
    "        hist['gen_data'][\"jpsi_muons_pt\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muons_pt\", \"Transverse Momentum for JPsi Muons; Pt; Events\", 50, 0, 50), \"JPsiMuon_pt\")\n",
    "        hist['gen_data'][\"jpsi_muons_eta\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muons_eta\", \"Pseudorapidity for JPsi Muons; Eta; Events\", 50, -3, 3), \"JPsiMuon_eta\")\n",
    "        hist['gen_data'][\"jpsi_muons_phi\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muons_phi\", \"Angle for JPsi Muons; Phi; Events\", 50, -3.5, 3.5), \"JPsiMuon_phi\")\n",
    "        hist['gen_data'][\"jpsi_muons_charge\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muons_charge\", \"Charge of JPsi Muons; Charge; Events\", 5, -2, 2), \"JPsiMuon_charge\")\n",
    "        hist['gen_data'][\"jpsi_muon_pts_in_peak\"] = rdfJPsiMuons['gen_data'].Histo2D((\"jpsi_muon_pts_in_peak\", \"J/Psi Muon Pts In Peak; Positive Muon Pt; Negative Muon Pt; Events\", 100, 0, 100, 100, 0, 100), \"JPsiMuonPositivePt\", \"JPsiMuonNegativePt\")\n",
    "        hist['gen_data'][\"jpsi_muon_isolation_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"jpsi_muon_isolation_in_peak\", \"J/Psi Pf Rel Iso 03 All Made From Muons In Peak; Pf Rel Iso 03 All; Events\", 50, 0, .5), \"JPsiMuonIsolationInPeak\")\n",
    "        hist['gen_data'][\"delta_eta_between_isolated_muon_and_jpsi_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_eta_between_isolated_muon_and_jpsi_in_peak\", \"Delta Eta Between Isolated Muon And J/Psi; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenIsolatedMuonAndJPsiInPeak\")\n",
    "        hist['gen_data'][\"delta_phi_between_isolated_muon_and_jpsi_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_phi_between_isolated_muon_and_jpsi_in_peak\", \"Delta Phi Between Isolated Muon And J/Psi; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenIsolatedMuonAndJPsiInPeak\")\n",
    "        hist['gen_data'][\"delta_r_between_isolated_muon_and_jpsi_in_peak\"] = rdfJPsiMuons['gen_data'].Histo1D((\"delta_r_between_isolated_and_jpsi_in_peak\", \"Delta R Between Isolated Muon And J/Psi; Delta R; Events\", 48, 0, 6), \"DeltaRBetweenIsolatedMuonAndJPsiInPeak\")        \n",
    "\n",
    "        hist['gen_data'][\"mc_truth_purity_delta_r_lower\"] = rdfMCTruth['gen_data'].Histo1D((\"mc_truth_purity_delta_r_lower\", \"Purity Measurement - Delta R Below Cutoff; Purity; Events\", 5, -2, 2), \"MCTruthPurityDeltaRLowerRVec\")\n",
    "#        hist['gen_data'][\"mc_truth_purity_delta_r_higher\"] = rdfMCTruth['gen_data'].Histo1D((\"mc_truth_purity_delta_r_higher\", \"Purity Measurement - Delta R Above Cutoff; Purity; Events\", 5, -2, 2), \"MCTruthPurityDeltaRHigherRVec\")\n",
    "\n",
    "        hist['gen_data'][\"parent_top_pt_same_parent_case\"] = rdfMCTruth['gen_data'].Histo1D((\"parent_top_pt_same_parent_case\", \"Parent Top Pt, Same Parent Case, dR < 2.5; Pt; Events\", 60, 0, 300), \"ParentTopPtSameParent\")\n",
    "        hist['gen_data'][\"parent_top_pt_different_parent_case\"] = rdfMCTruth['gen_data'].Histo1D((\"parent_top_pt_different_parent_case\", \"Isolated Muon Parent Top Pt, Different Parent Case, dR < 2.5; Pt; Events\", 60, 0, 300), \"ParentTopPtDifferentParent\")\n",
    "        hist['gen_data'][\"parent_top_pt_same_parent_case_ht\"] = rdfMCTruth['gen_data'].Histo1D((\"parent_top_pt_same_parent_case_ht\", \"Parent Top Pt, Same Parent Case, Ht > 300; Pt; Events\", 80, 0, 400), \"ParentTopPtSameParentHt\")\n",
    "        hist['gen_data'][\"parent_top_pt_different_parent_case_ht\"] = rdfMCTruth['gen_data'].Histo1D((\"parent_top_pt_different_parent_case_ht\", \"Isolated Muon Parent Top Pt, Different Parent Case, Ht > 300; Pt; Events\", 80, 0, 400), \"ParentTopPtDifferentParentHt\")\n",
    "        hist['gen_data'][\"parent_top_pt_same_parent_case_num_jets\"] = rdfMCTruth['gen_data'].Histo1D((\"parent_top_pt_same_parent_case_num_jets\", \"Parent Top Pt, Same Parent Case, NumJets = 3; Pt; Events\", 80, 0, 400), \"ParentTopPtSameParentNumJets\")\n",
    "        hist['gen_data'][\"parent_top_pt_different_parent_case_num_jets\"] = rdfMCTruth['gen_data'].Histo1D((\"parent_top_pt_different_parent_case_num_jets\", \"J/Psi Muon Parent Top Pt, Different Parent Case, NumJets = 3; Pt; Events\", 80, 0, 400), \"ParentTopPtDifferentParentNumJets\")\n",
    "        \n",
    "        hist['gen_data'][\"delta_r_vs_ht_with_ht_in_range\"] = rdfMCTruth['gen_data'].Histo2D((\"delta_r_vs_ht_with_ht_in_range\", \"Delta R vs Ht for Ht > 300; Delta R; Ht; Events\", 50, 0, 6, 70, 250, 600), \"DeltaRBetweenIsolatedMuonAndJPsiInPeakWithHtInRange\", \"HtInRange\")\n",
    "\n",
    "    else:\n",
    "        \n",
    "        hist[sample][\"leading_isolated_muon_pt_initial\"] = rdfIsolatedMuonNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_pt_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Transverse Momentum (One Muon, No Electrons); Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_eta_initial\"] = rdfIsolatedMuonNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_eta_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Pseudorapidity (One Muon, No Electrons); Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_phi_initial\"] = rdfIsolatedMuonNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_phi_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Angle (One Muon, No Electrons); Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_mass_initial\"] = rdfIsolatedMuonNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_mass_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Mass (One Muon, No Electrons); Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_charge_initial\"] = rdfIsolatedMuonNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_charge_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Charge (One Muon, No Electrons); Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_pt_initial\"] = rdfIsolatedElectronNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_pt_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Transverse Momentum (One Electron, No Muons); Pt (GeV);Events\",100,20,220),\"LeadingIsolatedElectron_pt\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_eta_initial\"] = rdfIsolatedElectronNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_eta_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Pseudorapidity (One Electron, No Muons); Eta; Events\",100,-3,3),\"LeadingIsolatedElectron_eta\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_phi_initial\"] = rdfIsolatedElectronNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_phi_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Angle (One Electron, No Muons); Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedElectron_phi\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_mass_initial\"] = rdfIsolatedElectronNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_mass_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Mass (One Electron, No Muons); Mass(Gev); Events\",10,.0001,.001),\"LeadingIsolatedElectron_mass\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_charge_initial\"] = rdfIsolatedElectronNoHighWeights[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_charge_initial\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Charge (One Electron, No Muons); Charge; Events\",5,-2,2),\"LeadingIsolatedElectron_charge\",\"LumiXS\")\n",
    "        \n",
    "        hist[sample][\"met_before_met_cut\"] = rdfIsolatedMuonNoHighWeights[sample].Histo1D((sample + \"_\" + \"met_before_met_cut\", \"Monte Carlo \" + sample + \"; MET Before MET Cut; Pt (GeV); Events\",100,0,250), \"METBeforeMETCut\", \"LumiXS\")\n",
    "        hist[sample][\"met_after_met_cut\"] = rdfIsolatedMuonAfterMETCut[sample].Histo1D((sample + \"_\" + \"met_after_met_cut\", \"Monte Carlo \" + sample + \"; MET After MET Cut; Pt (GeV); Events\",100,0,250), \"METAfterMETCut\", \"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_pt_after_met_cut\"] = rdfIsolatedMuonAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_pt_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Transverse Momentum After MET Cut; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_eta_after_met_cut\"] = rdfIsolatedMuonAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_eta_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Pseudorapidity After MET Cut; Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_phi_after_met_cut\"] = rdfIsolatedMuonAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_phi_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Angle After MET Cut; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_mass_after_met_cut\"] = rdfIsolatedMuonAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_mass_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Mass After MET Cut; Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_charge_after_met_cut\"] = rdfIsolatedMuonAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_charge_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Charge After MET Cut; Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_pt_after_met_cut\"] = rdfIsolatedElectronAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_pt_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Transverse Momentum After MET Cut; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedElectron_pt\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_eta_after_met_cut\"] = rdfIsolatedElectronAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_eta_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Pseudorapidity After MET Cut; Eta; Events\",100,-3,3),\"LeadingIsolatedElectron_eta\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_phi_after_met_cut\"] = rdfIsolatedElectronAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_phi_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Angle After MET Cut; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedElectron_phi\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_mass_after_met_cut\"] = rdfIsolatedElectronAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_mass_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Mass After MET Cut; Mass(Gev); Events\",10,.0001,.001),\"LeadingIsolatedElectron_mass\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_electron_charge_after_met_cut\"] = rdfIsolatedElectronAfterMETCut[sample].Histo1D((sample + \"_\" + \"leading_isolated_electron_charge_after_met_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Electron Charge After MET Cut; Charge; Events\",5,-2,2),\"LeadingIsolatedElectron_charge\",\"LumiXS\")\n",
    "        \n",
    "        hist[sample][\"number_of_jets_initial\"] = rdfIsolatedMuonAfterMETCut[sample].Histo1D((sample + \"_\" + \"number_of_jets_initial\", \"Monte Carlo \" + sample +\"; Number Of Jets Before Jet Cut; Number Of Jets; Events\", 20, 0, 20), \"Num_Jets\", \"LumiXS\")\n",
    "        hist[sample][\"number_of_jets\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"number_of_jets\", \"Monte Carlo \" + sample +\"; Number Of Jets; Number Of Jets; Events\", 12, 0, 12), \"Num_Jets\", \"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_pt_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_pt_after_jet_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Transverse Momentum After Jet Cut; Pt (GeV);Events\",100,20,220),\"LeadingIsolatedMuon_pt\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_eta_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_eta_after_jet_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Pseudorapidity After Jet Cut; Eta; Events\",100,-3,3),\"LeadingIsolatedMuon_eta\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_phi_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_phi_after_jet_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Angle After Jet Cut; Phi (Radians); Events\",100,-3.5,3.5),\"LeadingIsolatedMuon_phi\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_mass_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_mass_after_jet_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Mass After Jet Cut; Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_charge_after_jet_cut\"] = rdfJetAndIsolatedLeptonFiltered[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_charge_after_jet_cut\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Charge After Jet Cut; Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\",\"LumiXS\")\n",
    "        \n",
    "        hist[sample][\"number_of_jpsi_muons_initial\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"number_of_jpsi_muons_initial\", \"Monte Carlo \" + sample +\"; Number Of JPsi Muons Before JPsi Muon Cut; Number Of Muons; Events\", 10, 0, 9), \"Num_JPsi_Muons\", \"LumiXS\")\n",
    "        hist[sample][\"number_of_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"number_of_jpsi_muons\", \"Monte Carlo \" + sample +\"; Number Of JPsi Muons; Number Of Muons; Events\", 7, 0, 7), \"Num_JPsi_Muons\", \"LumiXS\")\n",
    "        hist[sample][\"number_of_jpsis\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"number_of_jpsis\", \"Monte Carlo \" + sample +\"; Number Of JPsis; Number Of JPsis; Events\", 4, 0, 4), \"Num_JPsi\", \"LumiXS\")\n",
    "        \n",
    "        \n",
    "        # Final Results\n",
    "        hist[sample][\"leading_isolated_muon_pt\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_pt\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Transverse Momentum (One Muon, No Electrons); Pt (GeV);Events\",50,20,220),\"LeadingIsolatedMuon_pt\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_eta\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_eta\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Pseudorapidity (One Muon, No Electrons); Eta; Events\",30,-3,3),\"LeadingIsolatedMuon_eta\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_phi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_phi\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Angle (One Muon, No Electrons); Phi (Radians); Events\",30,-3.5,3.5),\"LeadingIsolatedMuon_phi\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_mass\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_mass\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Mass (One Muon, No Electrons); Mass(Gev); Events\",10,.1,.2),\"LeadingIsolatedMuon_mass\",\"LumiXS\")\n",
    "        hist[sample][\"leading_isolated_muon_charge\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"leading_isolated_muon_charge\", \"Monte Carlo \" + sample + \";Leading Isolated Muon Charge (One Muon, No Electrons); Charge; Events\",5,-2,2),\"LeadingIsolatedMuon_charge\",\"LumiXS\")\n",
    "        hist[sample][\"isolated_muon_pf_rel_iso_03_all\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"isolated_muon_pf_rel_iso_03_all\", \"Monte Carlo\" + sample + \"; Isolated Muon PfRelIso03_All; Isolated Muon PfRelIso03_All; Events\", 25, 0, .25), \"IsolatedMuon_pfRelIso03_all\", \"LumiXS\")\n",
    "        \n",
    "        hist[sample][\"jet1_pt\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jet1_pt\", \"Monte Carlo \" + sample + \"; Jet Transverse Momentum for Leading Jet; Pt (GeV); Events\", 50, 20, 200), \"SJet1_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jet2_pt\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jet2_pt\", \"Monte Carlo \" + sample + \"; Jet Transverse Momentum for Subeading Jet; Pt (GeV); Events\", 50, 20, 200), \"SJet2_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jet1_eta\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jet1_eta\", \"Monte Carlo \" + sample + \"; Jet Pseudorapidity for Leading Jet; Eta; Events\", 30, -3, 3), \"SJet1_eta\", \"LumiXS\")\n",
    "        hist[sample][\"jet2_eta\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jet2_eta\", \"Monte Carlo \" + sample +\"; Jet Pseudorapidity for Subeading Jet; Eta; Events\", 30, -3, 3), \"SJet2_eta\", \"LumiXS\")\n",
    "        hist[sample][\"jet1_phi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jet1_phi\", \"Monte Carlo \" + sample + \"; Jet Angle for Leading Jet; Phi (Radians); Events\", 30, -3.5, 3.5), \"SJet1_phi\", \"LumiXS\")\n",
    "        hist[sample][\"jet2_phi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jet2_phi\", \"Monte Carlo \" + sample +\"; Jet Angle for Subleading Jet; Phi (Radians); Events\", 30, -3.5, 3.5), \"SJet2_phi\", \"LumiXS\")\n",
    "        hist[sample][\"transverse_mass\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"transverse_mass\", \"Monte Carlo \" + sample +\"; Transverse Mass; Transverse Mass (GeV); Events\", 40, 0, 150), \"MTofMETandMu\", \"LumiXS\")\n",
    "        hist[sample][\"ht\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"ht\", \"Monte Carlo \" + sample + \"; Ht; Ht; Events\", 50, 0, 1000), \"Ht\", \"LumiXS\")\n",
    "        \n",
    "        hist[sample][\"met\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"met\", \"Monte Carlo \" + sample + \"; MET; Pt (GeV); Events\",50,0,250), \"METAfterMETCut\", \"LumiXS\")\n",
    "                \n",
    "        hist[sample][\"invariant_mass_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"invariant_mass_jpsi_muons\", \"Monte Carlo \" + sample + \"; Invariant Masses for J/Psi Candidate Muons (Oppositely Charged); Invariant Masses; Events\", 100, .5, 12), \"InvariantMassJPsiMuons\", \"LumiXS\")\n",
    "        hist[sample][\"invariant_masses_zoomed\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"invariant_masses_zoomed\", \"Monte Carlo \" + sample + \"; Invariant Masses for J/Psi Candidate Muons (Oppositely Charged); Invariant Masses; Events\", 50, 2.8, 3.4), \"InvariantMassJPsiMuons\", \"LumiXS\")\n",
    "        hist[sample][\"invariant_mass_jpsi_muons_and_isolated_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"invariant_mass_jpsi_and_isolated_muons\", \"Monte Carlo \" + sample + \"; Invariant Masses for J/Psi Candidate And Isolated Muons; Invariant Masses; Events\", 40, 0, 200), \"InvariantMassJPsiMuonsAndIsolatedMuons\", \"LumiXS\")\n",
    "        hist[sample][\"delta_eta_between_isolated_and_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_eta_betweeen_isolated_and_jpsi_muons\", \"Monte Carlo \" + sample + \"; Delta Eta for Isolated Muon - JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenIsolatedAndJPsiMuon\", \"LumiXS\")\n",
    "        hist[sample][\"delta_phi_between_isolated_and_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_phi_betweeen_isolated_and_jpsi_muons\", \"Monte Carlo \" + sample + \"; Delta Phi for Isolated Muon - JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenIsolatedAndJPsiMuon\", \"LumiXS\")\n",
    "        hist[sample][\"delta_r_between_isolated_and_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_r_betweeen_isolated_and_jpsi_muons\", \"Monte Carlo \" + sample + \"; Delta R for Isolated and JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaRBetweenIsolatedAndJPsiMuon\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_pt\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_pt\", \"Monte Carlo \" + sample + \"; Transverse Momentum for JPsi; Pt; Events\", 240, 0, 120), \"JPsi_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_eta\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_eta\", \"Monte Carlo \" + sample + \"; Pseudorapidity for JPsi; Eta; Events\", 50, -3, 3), \"JPsi_eta\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_phi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_phi\", \"Monte Carlo \" + sample + \"; Angle for JPsi; Phi; Events\", 50, -3.5, 3.5), \"JPsi_phi\", \"LumiXS\")\n",
    "        hist[sample][\"delta_eta_between_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_eta_between_jpsi_muons\", \"Monte Carlo \" + sample + \"; Delta Eta for JPsi Muons; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenJPsiMuons\", \"LumiXS\")\n",
    "        hist[sample][\"delta_phi_between_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_phi_between_jpsi_muons\", \"Monte Carlo \" + sample + \"; Delta Phi for JPsi Muons; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenJPsiMuons\", \"LumiXS\")\n",
    "        hist[sample][\"delta_r_between_jpsi_muons\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_r_between_jpsi_muons\", \"Monte Carlo \" + sample + \"; Delta R for JPsi Muons; Delta R; Events\", 50, 0, 6), \"DeltaRBetweenJPsiMuons\", \"LumiXS\")\n",
    "        hist[sample][\"delta_r_between_jpsi_muons_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_r_between_jpsi_muons_in_peak\", \"Monte Carlo \" + sample + \"; Delta R for JPsi Muons In Peak; Delta R; Events\", 50, 0, 1), \"DeltaRBetweenJPsiMuonsInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"delta_eta_between_isolated_muon_and_jpsi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_eta_between_isolated_muon_and_jpsi\", \"Monte Carlo \" + sample + \"; Delta Eta for Isolated Muon And JPsi; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenIsolatedMuonAndJPsi\", \"LumiXS\")\n",
    "        hist[sample][\"delta_phi_between_isolated_muon_and_jpsi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_phi_between_isolated_muon_and_jpsi\", \"Monte Carlo \" + sample + \"; Delta Phi for Isolated Muon And JPsi; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenIsolatedMuonAndJPsi\", \"LumiXS\")\n",
    "        hist[sample][\"delta_r_between_isolated_muon_and_jpsi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_r_between_isolated_muon_and_jpsi\", \"Monte Carlo \" + sample + \"; Delta R for Isolated Muon And JPsi; Delta R; Events\", 50, 0, 6), \"DeltaRBetweenIsolatedMuonAndJPsi\", \"LumiXS\")\n",
    "        \n",
    "        \n",
    "        hist[sample][\"jpsi_muon_pt\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muon_pt\", \"Monte Carlo\" + sample + \"; JPsi Muon Pt - Muon Id Medium, Iso Id Tight; JPsi Muon Pt; Events\", 100, 0, 100), \"JPsiMuon_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muon_pf_rel_iso_03_all\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muon_pf_rel_iso_03_all\", \"Monte Carlo\" + sample + \"; JPsi Muon Pf Rel Iso 03 All - Muon Id Medium, Iso Id Tight; JPsi Muon Pf Rel Iso 03 All; Events\", 50, 0, .5), \"JPsiMuon_pfRelIso03_all\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muon_pf_iso_id\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muon_pf_iso_id\", \"Monte Carlo\" + sample + \"; JPsi Muon Pf Iso Id - Muon Id Medium, Iso Id Tight; JPsi Muon Pf Iso Id; Events\", 6, .5, 6.5), \"JPsiMuon_pfIsoid\", \"LumiXS\")\n",
    "        hist[sample][\"isolated_muons_in_range_pfRelIso03_all\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"isolated_muons_in_range_pfRelIso03_all\", \"Monte Carlo\" + sample + \"; PfRelIso03_All For Isolated Muons In 90-120 GeV Range; PfRelIso03_All; Events\", 50, 0, .5), \"IsolatedMuonsInRangeInvariantMassPlot_pfRelIso03_all\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_in_range_pfRelIso03_all\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_in_range_pfRelIso03_all\", \"Monte Carlo\" + sample + \"; PfRelIso03_All For JPsi Muons In 90-120 GeV Range; PfRelIso03_All; Events\", 50, 0, .5), \"JPsiMuonsInRangeInvariantMassPlot_pfRelIso03_all\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_mass_muons_in_range\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_mass_muons_in_range\", \"Monte Carlo\" + sample + \"; JPsi Mass For JPsis In 90-120 GeV Range; JPsi Mass; Events\", 200, 0, 100), \"JPsiMassesInRangeInvariantMassPlot\")\n",
    "        hist[sample][\"pt_at_low_delta_r\"] = rdfJPsiMuons[sample].Histo2D((sample + \"_\" + \"pt_at_low_delta_r\", \"Monte Carlo\" + sample + \"; Isolated Muon and JPsi Muon Pt at Delta R < 0.3; Isolated Muon Pt; JPsi Muon Pt; Events\", 100, 20, 220, 100, 0, 100), \"IsolatedMuonPtAtLowDeltaR\", \"JPsiMuonPtAtLowDeltaR\", \"LumiXS\")\n",
    "        \n",
    "        \n",
    "        hist[sample][\"jpsi_mass_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_mass_in_peak\", \"Monte Carlo\" + sample + \"; J/Psi Mass Made from Muons In Peak; J/Psi Mass; Events\", 40, 2.9, 3.3), \"JPsiMassInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"delta_eta_for_jpsi_muons_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_eta_for_jpsi_muons_in_peak\", \"Monte Carlo\" + sample + \"; Delta Eta For J/Psi Muons In Peak; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaForJPsiMuonsInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"delta_phi_for_jpsi_muons_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_phi_for_jpsi_muons_in_peak\", \"Monte Carlo\" + sample + \"; Delta Phi For J/Psi Muons In Peak; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiForJPsiMuonsInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"delta_r_for_jpsi_muons_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_r_for_jpsi_muons_in_peak\", \"Monte Carlo\" + sample + \"; Delta R For J/Psi Muons In Peak; Delta R; Events\", 50, 0, 6), \"DeltaRForJPsiMuonsInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_charge_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_charge_in_peak\", \"Monte Carlo\" + sample + \"; J/Psi Muons In Peak Charge; Charge; Events\", 5, -2, 2), \"JPsiMuon_charge\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_pt_with_muon_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_pt_with_muon_in_peak\", \"Monte Carlo\" + sample + \"; J/Psi Pt With Muons In Peak; Pt; Events\", 40, 0, 200), \"JPsiPtWithMuonInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muon_pts_in_peak\"] = rdfJPsiMuons[sample].Histo2D((sample + \"_\" + \"jpsi_muon_pts_in_peak\", \"Monte Carlo\" + sample + \"; J/Psi Muon Pts In Peak; Positive Muon Pts; Negative Muon Pts; Events\", 200, 0, 200, 100, 0, 100), \"JPsiMuonPositivePt\", \"JPsiMuonNegativePt\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_pt\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_pt\", \"Monte Carlo \" + sample + \"; Transverse Momentum for JPsi Muons; Pt; Events\", 50, 0, 50), \"JPsiMuon_pt\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_eta\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_eta\", \"Monte Carlo \" + sample + \"; Pseudorapidity for JPsi Muons; Eta; Events\", 50, -3, 3), \"JPsiMuon_eta\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_phi\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muons_phi\", \"Monte Carlo \" + sample + \"; Angle for JPsi Muons; Phi; Events\", 50, -3.5, 3.5), \"JPsiMuon_phi\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muons_charge\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muon_charge\", \"Monte Carlo\" + sample + \"; Charge of JPsi Muons; Charge; Events\", 5, -2, 2), \"JPsiMuon_charge\", \"LumiXS\")\n",
    "        hist[sample][\"jpsi_muon_isolation_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"jpsi_muon_isolation_in_peak\", \"Monte Carlo\" + sample + \"; J/Psi Pf Rel Iso 03 All Made From Muons In Peak; Pf Rel Iso 03 All; Events\", 50, 0, .5), \"JPsiMuonIsolationInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"delta_eta_between_isolated_muon_and_jpsi_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_eta_between_isolated_muon_and_jpsi_in_peak\", \"Monte Carlo\" + sample + \"; Delta Eta Between Isolated Muon And J/Psi; Delta Eta; Events\", 50, 0, 6), \"DeltaEtaBetweenIsolatedMuonAndJPsiInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"delta_phi_between_isolated_muon_and_jpsi_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_phi_between_isolated_muon_and_jpsi_in_peak\", \"Monte Carlo\" + sample + \"; Delta Phi Between Isolated Muon And J/Psi; Delta Phi; Events\", 50, -3.5, 3.5), \"DeltaPhiBetweenIsolatedMuonAndJPsiInPeak\", \"LumiXS\")\n",
    "        hist[sample][\"delta_r_between_isolated_muon_and_jpsi_in_peak\"] = rdfJPsiMuons[sample].Histo1D((sample + \"_\" + \"delta_r_between_isolated_muon_and_jpsi_in_peak\", \"Monte Carlo\" + sample + \"Delta R Between Isolated Muon And J/Psi; Delta R; Events\", 48, 0, 6), \"DeltaRBetweenIsolatedMuonAndJPsiInPeak\", \"LumiXS\")\n",
    "\n",
    "        hist[sample][\"mc_truth_purity_delta_r_lower\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"mc_truth_purity_delta_r_lower\", \"Monte Carlo\" + sample + \";Purity Measurement - Delta R Below Cutoff; Purity; Events\", 5, -2, 2), \"MCTruthPurityDeltaRLowerRVec\", \"LumiXS\")\n",
    "#        hist[sample][\"mc_truth_purity_delta_r_lower\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"mc_truth_purity_delta_r_lower\", \"Monte Carlo\" + sample + \";Purity Measurement - Delta R Below Cutoff; Purity; Events\", 5, -2, 2), \"MCTruthPurityDeltaRLowerRVec\", \"LumiXS\")\n",
    "#        hist[sample][\"mc_truth_purity_delta_r_higher\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"mc_truth_purity_delta_r_higher\", \"Monte Carlo\" + sample + \";Purity Measurement - Delta R Above Cutoff; Purity; Events\", 5, -2, 2), \"MCTruthPurityDeltaRHigherRVec\", \"LumiXS\")\n",
    "\n",
    "        hist[sample][\"parent_top_pt_same_parent_case\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"parent_top_pt_same_parent_case\", \"Monte Carlo\" + sample + \";Parent Top Pt, Same Parent Case, dR < 2.5; Pt; Events\", 60, 0, 300), \"ParentTopPtSameParent\", \"LumiXS\")\n",
    "        hist[sample][\"parent_top_pt_different_parent_case\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"parent_top_pt_different_parent_case\", \"Monte Carlo\" + sample + \";Isolated Muon Parent Top Pt, Different Parent Case, dR < 2.5; Pt; Events\", 60, 0, 300), \"ParentTopPtDifferentParent\", \"LumiXS\")\n",
    "        hist[sample][\"parent_top_pt_same_parent_case_ht\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"parent_top_pt_same_parent_case_ht\", \"Monte Carlo\" + sample + \";Parent Top Pt, Same Parent Case, Ht > 300; Pt; Events\", 80, 0, 400), \"ParentTopPtSameParentHt\", \"LumiXS\")\n",
    "        hist[sample][\"parent_top_pt_different_parent_case_ht\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"parent_top_pt_different_parent_case_ht\", \"Monte Carlo\" + sample + \";Isolated Muon Parent Top Pt, Different Parent Case, Ht > 300; Pt; Events\", 80, 0, 400), \"ParentTopPtDifferentParentHt\", \"LumiXS\")\n",
    "        hist[sample][\"parent_top_pt_same_parent_case_num_jets\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"parent_top_pt_same_parent_case_num_jets\", \"Monte Carlo\" + sample + \";Parent Top Pt, Same Parent Case, NumJets = 3; Pt; Events\", 80, 0, 400), \"ParentTopPtSameParentNumJets\", \"LumiXS\")\n",
    "        hist[sample][\"parent_top_pt_different_parent_case_num_jets\"] = rdfMCTruth[sample].Histo1D((sample + \"_\" + \"parent_top_pt_different_parent_case_num_jets\", \"Monte Carlo\" + sample + \";J/Psi Muon Parent Top Pt, Different Parent Case, NumJets = 3; Pt; Events\", 80, 0, 400), \"ParentTopPtDifferentParentNumJets\", \"LumiXS\")\n",
    "        \n",
    "        hist[sample][\"delta_r_vs_ht_with_ht_in_range\"] = rdfMCTruth[sample].Histo2D((\"delta_r_vs_ht_with_ht_in_range\", \"Delta R vs Ht for Ht > 300; Delta R; Ht; Events\", 50, 0, 6, 70, 250, 600), \"DeltaRBetweenIsolatedMuonAndJPsiInPeakWithHtInRange\", \"HtInRange\", \"LumiXS\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "prospective-permission",
   "metadata": {},
   "outputs": [],
   "source": [
    "for sample in dictOfListOfFiles:\n",
    "\n",
    "    ROOT.RDF.SaveGraph(rdf[sample], str(sample) + \".dot\")\n",
    "    os.system(\"dot -Tpdf \" + str(sample) + \".dot > \" + str(sample) + \"_graph.pdf\" )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "small-volleyball",
   "metadata": {},
   "outputs": [],
   "source": [
    "for sample in dictOfListOfFiles:\n",
    "    #nparray[sample] = nparraynode[sample].AsNumpy([\"genWeight\", \"event\", \"run\"])\n",
    "\n",
    "    cutflow = report[sample].GetValue()\n",
    "    cutflow.Print()\n",
    "    \n",
    "    era = \"2018\"\n",
    "    channel = \"Mu\"\n",
    "    \n",
    "    if sample == \"MT171\":\n",
    "        process = \"TTToSemileptonic\"\n",
    "        syst = \"TopMassDown\"\n",
    "        \n",
    "    elif sample == \"MT175\":\n",
    "        process = \"TTToSemileptonic\"\n",
    "        syst = \"TopMassUp\"\n",
    "        \n",
    "    else:\n",
    "        process = sample\n",
    "        syst = \"nominal\"\n",
    "\n",
    "    outFile = ROOT.TFile.Open(\"{}_{}_{}.root\".format(era, channel, process), \"RECREATE\")\n",
    "    for name, hist_pointer in hist[sample].items():\n",
    "        print(hist_pointer)\n",
    "        hist_value = hist_pointer.GetValue()\n",
    "        \n",
    "        hist_value.SetName(\"{}___{}___{}___{}___{}\".format(era, channel, process, name, syst))\n",
    "        print(hist_value)\n",
    "        hist_value.Write()\n",
    "\n",
    "    outFile.Close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "58cd86df",
   "metadata": {},
   "outputs": [],
   "source": [
    "# for item in mureport:\n",
    "#     print(item)\n",
    "#     mureport[item].Print()\n",
    "#print(nparray['MonteCarloWJetsToLNu'].keys())\n",
    "\n",
    "#a = np.sort(nparray['MonteCarloWJetsToLNu']['genWeight'])\n",
    "\n",
    "#print(a[:10:-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16ec3f98",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  },
  "sparkconnect": {
   "bundled_options": [],
   "list_of_options": []
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
